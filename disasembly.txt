
main.elf:     file format elf32-littlearm


Disassembly of section .text:

00000000 <__isr_vector>:
   0:	00 80 00 20 ad 02 00 00 ed 02 00 00 ed 02 00 00     ... ............
  10:	ed 02 00 00 ed 02 00 00 ed 02 00 00 00 00 00 00     ................
	...
  2c:	ed 02 00 00 ed 02 00 00 00 00 00 00 ed 02 00 00     ................
  3c:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
  4c:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
  5c:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
  6c:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
  7c:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
  8c:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
  9c:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
  ac:	00 00 00 00 ed 02 00 00 ed 02 00 00 cd 07 00 00     ................
	...
  c4:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
  d4:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
	...
  ec:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
  fc:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
 10c:	ed 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
 124:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
 134:	ed 02 00 00 ed 02 00 00 ed 02 00 00 00 00 00 00     ................
	...
 150:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
	...
 1b0:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
 1c0:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
 1d0:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
 1e0:	ed 02 00 00 ed 02 00 00 ed 02 00 00 00 00 00 00     ................
	...
 258:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
 268:	ed 02 00 00                                         ....

0000026c <__do_global_dtors_aux>:
 26c:	b510      	push	{r4, lr}
 26e:	4c05      	ldr	r4, [pc, #20]	; (284 <__do_global_dtors_aux+0x18>)
 270:	7823      	ldrb	r3, [r4, #0]
 272:	b933      	cbnz	r3, 282 <__do_global_dtors_aux+0x16>
 274:	4b04      	ldr	r3, [pc, #16]	; (288 <__do_global_dtors_aux+0x1c>)
 276:	b113      	cbz	r3, 27e <__do_global_dtors_aux+0x12>
 278:	4804      	ldr	r0, [pc, #16]	; (28c <__do_global_dtors_aux+0x20>)
 27a:	f3af 8000 	nop.w
 27e:	2301      	movs	r3, #1
 280:	7023      	strb	r3, [r4, #0]
 282:	bd10      	pop	{r4, pc}
 284:	20000010 	.word	0x20000010
 288:	00000000 	.word	0x00000000
 28c:	00000920 	.word	0x00000920

00000290 <frame_dummy>:
 290:	b508      	push	{r3, lr}
 292:	4b03      	ldr	r3, [pc, #12]	; (2a0 <frame_dummy+0x10>)
 294:	b11b      	cbz	r3, 29e <frame_dummy+0xe>
 296:	4903      	ldr	r1, [pc, #12]	; (2a4 <frame_dummy+0x14>)
 298:	4803      	ldr	r0, [pc, #12]	; (2a8 <frame_dummy+0x18>)
 29a:	f3af 8000 	nop.w
 29e:	bd08      	pop	{r3, pc}
 2a0:	00000000 	.word	0x00000000
 2a4:	20000014 	.word	0x20000014
 2a8:	00000920 	.word	0x00000920

000002ac <Reset_Handler>:
 *    __data_start__: VMA of start of the section to copy to
 *    __data_end__: VMA of end of the section to copy to
 *
 *  All addresses must be aligned to 4 bytes boundary.
 */
	ldr	r1, =__etext
 2ac:	490a      	ldr	r1, [pc, #40]	; (2d8 <Reset_Handler+0x2c>)
	ldr	r2, =__data_start__
 2ae:	4a0b      	ldr	r2, [pc, #44]	; (2dc <Reset_Handler+0x30>)
	ldr	r3, =__data_end__
 2b0:	4b0b      	ldr	r3, [pc, #44]	; (2e0 <Reset_Handler+0x34>)

.L_loop1:
	cmp	r2, r3
 2b2:	429a      	cmp	r2, r3
	ittt	lt
 2b4:	bfbe      	ittt	lt
	ldrlt	r0, [r1], #4
 2b6:	f851 0b04 	ldrlt.w	r0, [r1], #4
	strlt	r0, [r2], #4
 2ba:	f842 0b04 	strlt.w	r0, [r2], #4
	blt	.L_loop1
 2be:	e7f8      	blt.n	2b2 <Reset_Handler+0x6>
 *    __bss_start__: start of the BSS section.
 *    __bss_end__: end of the BSS section.
 *
 *  Both addresses must be aligned to 4 bytes boundary.
 */
	ldr	r1, =__bss_start__
 2c0:	4908      	ldr	r1, [pc, #32]	; (2e4 <Reset_Handler+0x38>)
	ldr	r2, =__bss_end__
 2c2:	4a09      	ldr	r2, [pc, #36]	; (2e8 <Reset_Handler+0x3c>)

	movs	r0, 0
 2c4:	2000      	movs	r0, #0
.L_loop3:
	cmp	r1, r2
 2c6:	4291      	cmp	r1, r2
	itt	lt
 2c8:	bfbc      	itt	lt
	strlt	r0, [r1], #4
 2ca:	f841 0b04 	strlt.w	r0, [r1], #4
	blt	.L_loop3
 2ce:	e7fa      	blt.n	2c6 <Reset_Handler+0x1a>
#endif /* __STARTUP_CLEAR_BSS_MULTIPLE || __STARTUP_CLEAR_BSS */

#ifndef __NO_SYSTEM_INIT
	bl	SystemInit
 2d0:	f000 f998 	bl	604 <SystemInit>
#endif

#ifndef __START
#define __START _start
#endif
	bl	__START
 2d4:	f000 f974 	bl	5c0 <main>
	ldr	r1, =__etext
 2d8:	00000924 	.word	0x00000924
	ldr	r2, =__data_start__
 2dc:	20000000 	.word	0x20000000
	ldr	r3, =__data_end__
 2e0:	20000010 	.word	0x20000010
	ldr	r1, =__bss_start__
 2e4:	20000010 	.word	0x20000010
	ldr	r2, =__bss_end__
 2e8:	200000a8 	.word	0x200000a8

000002ec <ADC_0_Sequence_0_Handler>:
	.align	1
	.thumb_func
	.weak	Default_Handler
	.type	Default_Handler, %function
Default_Handler:
	b	.
 2ec:	e7fe      	b.n	2ec <ADC_0_Sequence_0_Handler>
 2ee:	bf00      	nop

000002f0 <_ZN4Nvic17disableInterruptsEv>:
 *         value to void.
 */
#pragma GCC push_options
#pragma GCC optimize("O0")
uint32_t Nvic::disableInterrupts(void)
{
 2f0:	b480      	push	{r7}
 2f2:	b083      	sub	sp, #12
 2f4:	af00      	add	r7, sp, #0

        "mrs     r0, PRIMASK\n"
        "cpsid   i\n"
        "bx      lr\n"
        : "=r" (ui32Ret)
    );
 2f6:	f3ef 8010 	mrs	r0, PRIMASK
 2fa:	b672      	cpsid	i
 2fc:	4770      	bx	lr
 2fe:	607b      	str	r3, [r7, #4]

    return(ui32Ret);
 300:	687b      	ldr	r3, [r7, #4]
}
 302:	4618      	mov	r0, r3
 304:	370c      	adds	r7, #12
 306:	46bd      	mov	sp, r7
 308:	f85d 7b04 	ldr.w	r7, [sp], #4
 30c:	4770      	bx	lr

0000030e <_ZN4Nvic16enableInterruptsEv>:
 *         value to void.
 */
#pragma GCC push_options
#pragma GCC optimize("O0")
uint32_t Nvic::enableInterrupts(void)
{
 30e:	b480      	push	{r7}
 310:	b083      	sub	sp, #12
 312:	af00      	add	r7, sp, #0

        "mrs     r0, PRIMASK\n"
        "cpsie   i\n"
        "bx      lr\n"
        : "=r" (ui32Ret)
    );
 314:	f3ef 8010 	mrs	r0, PRIMASK
 318:	b662      	cpsie	i
 31a:	4770      	bx	lr
 31c:	607b      	str	r3, [r7, #4]

    return(ui32Ret);
 31e:	687b      	ldr	r3, [r7, #4]
}
 320:	4618      	mov	r0, r3
 322:	370c      	adds	r7, #12
 324:	46bd      	mov	sp, r7
 326:	f85d 7b04 	ldr.w	r7, [sp], #4
 32a:	4770      	bx	lr

0000032c <_ZN4Nvic3wfiEv>:
 *        module and waits for another interrupt.
 */
#pragma GCC push_options
#pragma GCC optimize("O0")
void Nvic::wfi(void)
{
 32c:	b480      	push	{r7}
 32e:	af00      	add	r7, sp, #0
    //
    asm volatile(

        "wfi     \n"
        "bx    lr\n"
    );
 330:	bf30      	wfi
 332:	4770      	bx	lr
    
}
 334:	46bd      	mov	sp, r7
 336:	f85d 7b04 	ldr.w	r7, [sp], #4
 33a:	4770      	bx	lr

0000033c <_ZN3PwmD1Ev>:
 * @brief empty deconstructor placeholder
 */
Pwm::~Pwm()
{

}
 33c:	4770      	bx	lr

0000033e <_ZN4Gpio4readEv>:
 * @brief Reads from a gpio pin.
 * @return Value of the gpio pin, either a 1 or 0.
 */
uint32_t Gpio::read()
{
    return((Register::getRegisterBitFieldStatus(((volatile uint32_t*)(baseAddress + GPIODATA_OFFSET)), gpio, 1, RW)));
 33e:	6903      	ldr	r3, [r0, #16]
 340:	6800      	ldr	r0, [r0, #0]
uint32_t Register::getRegisterBitFieldStatus(volatile uint32_t* address, uint32_t bit, uint32_t bitWidth, bitFieldPermission permission)
{
    if((permission == RW) || (permission == RO) || (permission == RW1C))
    {
        uint32_t select = ((((0xFFFFFFFF >> (32 - bitWidth)))) << bit);
        return(((*address) & select) >> bit);
 342:	f8d3 23fc 	ldr.w	r2, [r3, #1020]	; 0x3fc
        uint32_t select = ((((0xFFFFFFFF >> (32 - bitWidth)))) << bit);
 346:	2301      	movs	r3, #1
 348:	4083      	lsls	r3, r0
        return(((*address) & select) >> bit);
 34a:	4013      	ands	r3, r2
 34c:	fa23 f000 	lsr.w	r0, r3, r0
 350:	4770      	bx	lr

00000352 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0>:
 * @param value to be written to the bitfield
 * @param bit to be set or the first bit of the bitfield to be set
 * @param width of the bitfield
 * @param permission of the bitfield, read-only, write-only, etc...
 */
void Register::setRegisterBitFieldStatus(volatile uint32_t* address, uint32_t value, uint32_t bit, uint32_t bitWidth, bitFieldPermission permission)
 352:	b510      	push	{r4, lr}
        return;
    }
    
    else if((permission == RW) || (permission == WO) || (permission == RW1C))
    {
        uint32_t maxValue = (0xFFFFFFFF >> (32 - bitWidth));
 354:	f1c3 0420 	rsb	r4, r3, #32
 358:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 35c:	40e3      	lsrs	r3, r4

        if((value <= maxValue))
 35e:	428b      	cmp	r3, r1
 360:	d308      	bcc.n	374 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0+0x22>
        {
            uint32_t clear = (~(maxValue << bit));
            value = value << bit;
    
            (*address) &= clear;
 362:	6804      	ldr	r4, [r0, #0]
            uint32_t clear = (~(maxValue << bit));
 364:	4093      	lsls	r3, r2
            (*address) &= clear;
 366:	ea24 0303 	bic.w	r3, r4, r3
 36a:	6003      	str	r3, [r0, #0]
            (*address) |= value;
 36c:	6803      	ldr	r3, [r0, #0]
            value = value << bit;
 36e:	4091      	lsls	r1, r2
            (*address) |= value;
 370:	4319      	orrs	r1, r3
 372:	6001      	str	r1, [r0, #0]

    else
    {
        return;
    }
}
 374:	bd10      	pop	{r4, pc}

00000376 <_ZN4Gpio5writeE10setORClear.part.0>:
void Gpio::write(setORClear value)
 376:	b410      	push	{r4}
        Register::setRegisterBitFieldStatus(((volatile uint32_t*)(baseAddress + GPIODATA_OFFSET)), value, gpio, 1, RW);
 378:	6904      	ldr	r4, [r0, #16]
 37a:	6802      	ldr	r2, [r0, #0]
 37c:	2301      	movs	r3, #1
 37e:	f504 707f 	add.w	r0, r4, #1020	; 0x3fc
}
 382:	f85d 4b04 	ldr.w	r4, [sp], #4
 386:	f7ff bfe4 	b.w	352 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0>

0000038a <_ZN4Gpio14interruptClearEv>:
{
 38a:	b410      	push	{r4}
    Register::setRegisterBitFieldStatus(((volatile uint32_t*)(baseAddress + GPIOICR_OFFSET)), set, gpio, 1, RW);
 38c:	6904      	ldr	r4, [r0, #16]
 38e:	6802      	ldr	r2, [r0, #0]
 390:	2301      	movs	r3, #1
 392:	f204 401c 	addw	r0, r4, #1052	; 0x41c
 396:	4619      	mov	r1, r3
}
 398:	f85d 4b04 	ldr.w	r4, [sp], #4
 39c:	f7ff bfd9 	b.w	352 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0>

000003a0 <_ZN4Gpio10initializeEm9direction>:
    alternateFunction = gpio%100; //get encoding for alternate function
 3a0:	2364      	movs	r3, #100	; 0x64
{  
 3a2:	b570      	push	{r4, r5, r6, lr}
    alternateFunction = gpio%100; //get encoding for alternate function
 3a4:	fbb1 f5f3 	udiv	r5, r1, r3
 3a8:	fb03 1315 	mls	r3, r3, r5, r1
 3ac:	60c3      	str	r3, [r0, #12]
    (*this).gpio = (gpio%8);
 3ae:	f005 0307 	and.w	r3, r5, #7
 3b2:	6003      	str	r3, [r0, #0]
    baseAddress = GPIO_Port_AHB_BASE + (gpioPort) * 0x1000;
 3b4:	4b33      	ldr	r3, [pc, #204]	; (484 <Stack_Size+0x84>)
 3b6:	6103      	str	r3, [r0, #16]
    gpioPort = (gpio/8);
 3b8:	2105      	movs	r1, #5
{  
 3ba:	4604      	mov	r4, r0
 3bc:	2301      	movs	r3, #1
    gpioPort = (gpio/8);
 3be:	6141      	str	r1, [r0, #20]
    (*this).dir = dir;
 3c0:	7102      	strb	r2, [r0, #4]
void Register::setRegisterBitFieldStatus(volatile uint32_t* address, uint32_t value, uint32_t bit, uint32_t bitWidth, bitFieldPermission permission)
 3c2:	460a      	mov	r2, r1
 3c4:	4830      	ldr	r0, [pc, #192]	; (488 <Stack_Size+0x88>)
 3c6:	4619      	mov	r1, r3
 3c8:	f7ff ffc3 	bl	352 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0>
    while(Register::getRegisterBitFieldStatus(((volatile uint32_t*)(systemControlBase + PRGPIO_OFFSET)), (uint32_t)(gpioPort), 1, RO) == 0)
 3cc:	6961      	ldr	r1, [r4, #20]
        return(((*address) & select) >> bit);
 3ce:	482f      	ldr	r0, [pc, #188]	; (48c <Stack_Size+0x8c>)
        uint32_t select = ((((0xFFFFFFFF >> (32 - bitWidth)))) << bit);
 3d0:	2201      	movs	r2, #1
 3d2:	408a      	lsls	r2, r1
        return(((*address) & select) >> bit);
 3d4:	6803      	ldr	r3, [r0, #0]
 3d6:	4013      	ands	r3, r2
 3d8:	40cb      	lsrs	r3, r1
 3da:	d0fb      	beq.n	3d4 <_ZN4Gpio10initializeEm9direction+0x34>
    Register::setRegisterBitFieldStatus(((volatile uint32_t*)(baseAddress + GPIODIR_OFFSET)), (*this).dir, (*this).gpio, 1, RW);
 3dc:	6920      	ldr	r0, [r4, #16]
 3de:	6822      	ldr	r2, [r4, #0]
 3e0:	7921      	ldrb	r1, [r4, #4]
 3e2:	2301      	movs	r3, #1
 3e4:	f500 6080 	add.w	r0, r0, #1024	; 0x400
 3e8:	f7ff ffb3 	bl	352 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0>
    if(alternateFunction == 0)
 3ec:	e9d4 3003 	ldrd	r3, r0, [r4, #12]
 3f0:	b9eb      	cbnz	r3, 42e <Stack_Size+0x2e>
        if((*this).dir == input)
 3f2:	7923      	ldrb	r3, [r4, #4]
 3f4:	b933      	cbnz	r3, 404 <Stack_Size+0x4>
void Register::setRegisterBitFieldStatus(volatile uint32_t* address, uint32_t value, uint32_t bit, uint32_t bitWidth, bitFieldPermission permission)
 3f6:	2301      	movs	r3, #1
 3f8:	6822      	ldr	r2, [r4, #0]
 3fa:	4619      	mov	r1, r3
 3fc:	f500 60a2 	add.w	r0, r0, #1296	; 0x510
 400:	f7ff ffa7 	bl	352 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0>
        Register::setRegisterBitFieldStatus(((volatile uint32_t*)(baseAddress + GPIOAFSEl_OFFSET)), clear, (*this).gpio, 1, RW);
 404:	6920      	ldr	r0, [r4, #16]
 406:	6822      	ldr	r2, [r4, #0]
 408:	2301      	movs	r3, #1
 40a:	2100      	movs	r1, #0
 40c:	f500 6084 	add.w	r0, r0, #1056	; 0x420
 410:	f7ff ff9f 	bl	352 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0>
        Register::setRegisterBitFieldStatus(((volatile uint32_t*)(baseAddress + GPIODEN_OFFSET)), set, (*this).gpio, 1, RW);
 414:	6920      	ldr	r0, [r4, #16]
 416:	6822      	ldr	r2, [r4, #0]
 418:	2301      	movs	r3, #1
 41a:	4619      	mov	r1, r3
 41c:	f200 501c 	addw	r0, r0, #1308	; 0x51c
 420:	f7ff ff97 	bl	352 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0>
        Register::setRegisterBitFieldStatus(((volatile uint32_t*)(baseAddress + GPIOAMSEL_OFFSET)), clear, (*this).gpio, 1, RW);
 424:	6920      	ldr	r0, [r4, #16]
 426:	6822      	ldr	r2, [r4, #0]
 428:	2301      	movs	r3, #1
 42a:	2100      	movs	r1, #0
 42c:	e013      	b.n	456 <Stack_Size+0x56>
        alternateFunction = alternateFunction - 1; //Get rid of encoding offset
 42e:	3b01      	subs	r3, #1
 430:	60e3      	str	r3, [r4, #12]
 432:	2301      	movs	r3, #1
 434:	4619      	mov	r1, r3
 436:	f500 6084 	add.w	r0, r0, #1056	; 0x420
 43a:	462a      	mov	r2, r5
 43c:	f7ff ff89 	bl	352 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0>
        if(alternateFunction == 0)
 440:	e9d4 1003 	ldrd	r1, r0, [r4, #12]
 444:	b969      	cbnz	r1, 462 <Stack_Size+0x62>
 446:	2301      	movs	r3, #1
 448:	f200 501c 	addw	r0, r0, #1308	; 0x51c
 44c:	f7ff ff81 	bl	352 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0>
 450:	2301      	movs	r3, #1
            Register::setRegisterBitFieldStatus(((volatile uint32_t*)(baseAddress + GPIOAMSEL_OFFSET)), set, gpio, 1, RW);
 452:	6920      	ldr	r0, [r4, #16]
 454:	4619      	mov	r1, r3
 456:	f500 60a5 	add.w	r0, r0, #1320	; 0x528
}
 45a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 45e:	f7ff bf78 	b.w	352 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0>
 462:	2304      	movs	r3, #4
 464:	00aa      	lsls	r2, r5, #2
 466:	f200 502c 	addw	r0, r0, #1324	; 0x52c
 46a:	f7ff ff72 	bl	352 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0>
            Register::setRegisterBitFieldStatus(((volatile uint32_t*)(baseAddress + GPIODEN_OFFSET)), set, gpio, 1, RW);
 46e:	6920      	ldr	r0, [r4, #16]
 470:	2301      	movs	r3, #1
 472:	4619      	mov	r1, r3
 474:	f200 501c 	addw	r0, r0, #1308	; 0x51c
 478:	462a      	mov	r2, r5
 47a:	f7ff ff6a 	bl	352 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0>
            Register::setRegisterBitFieldStatus(((volatile uint32_t*)(baseAddress + GPIOAMSEL_OFFSET)), clear, gpio, 1, RW);
 47e:	6920      	ldr	r0, [r4, #16]
 480:	2301      	movs	r3, #1
 482:	e7d2      	b.n	42a <Stack_Size+0x2a>
 484:	4005d000 	.word	0x4005d000
 488:	400fe608 	.word	0x400fe608
 48c:	400fea08 	.word	0x400fea08

00000490 <_ZN4Gpio10initializeEm9directionm.constprop.0>:
void Gpio::initialize(uint32_t gpio, direction dir, uint32_t interruptPriority)
 490:	b510      	push	{r4, lr}
    (*this).interruptPriority = interruptPriority;
 492:	2303      	movs	r3, #3
void Gpio::initialize(uint32_t gpio, direction dir, uint32_t interruptPriority)
 494:	4604      	mov	r4, r0
    (*this).interruptPriority = interruptPriority;
 496:	6083      	str	r3, [r0, #8]
    initialize(gpio, dir);
 498:	2200      	movs	r2, #0
 49a:	f7ff ff81 	bl	3a0 <_ZN4Gpio10initializeEm9direction>
    Register::setRegisterBitFieldStatus(((volatile uint32_t*)(baseAddress + GPIOIM_OFFSET)), clear, (*this).gpio, 1, RW);
 49e:	6920      	ldr	r0, [r4, #16]
 4a0:	6822      	ldr	r2, [r4, #0]
 4a2:	2301      	movs	r3, #1
 4a4:	2100      	movs	r1, #0
 4a6:	f500 6082 	add.w	r0, r0, #1040	; 0x410
 4aa:	f7ff ff52 	bl	352 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0>
    Register::setRegisterBitFieldStatus(((volatile uint32_t*)(baseAddress + GPIOIS_OFFSET)), clear, (*this).gpio, 1, RW);
 4ae:	6920      	ldr	r0, [r4, #16]
 4b0:	6822      	ldr	r2, [r4, #0]
 4b2:	2301      	movs	r3, #1
 4b4:	2100      	movs	r1, #0
 4b6:	f200 4004 	addw	r0, r0, #1028	; 0x404
 4ba:	f7ff ff4a 	bl	352 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0>
    Register::setRegisterBitFieldStatus(((volatile uint32_t*)(baseAddress + GPIOIBE_OFFSET)), set, (*this).gpio, 1, RW);
 4be:	6920      	ldr	r0, [r4, #16]
 4c0:	6822      	ldr	r2, [r4, #0]
 4c2:	2301      	movs	r3, #1
 4c4:	4619      	mov	r1, r3
 4c6:	f500 6081 	add.w	r0, r0, #1032	; 0x408
 4ca:	f7ff ff42 	bl	352 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0>
    Register::setRegisterBitFieldStatus(((volatile uint32_t*)(baseAddress + GPIOICR_OFFSET)), set, (*this).gpio, 1, RW);
 4ce:	6920      	ldr	r0, [r4, #16]
 4d0:	6822      	ldr	r2, [r4, #0]
 4d2:	2301      	movs	r3, #1
 4d4:	4619      	mov	r1, r3
 4d6:	f200 401c 	addw	r0, r0, #1052	; 0x41c
 4da:	f7ff ff3a 	bl	352 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0>
    Register::setRegisterBitFieldStatus(((volatile uint32_t*)(baseAddress + GPIOIM_OFFSET)), set, (*this).gpio, 1, RW);
 4de:	6920      	ldr	r0, [r4, #16]
 4e0:	6822      	ldr	r2, [r4, #0]
 4e2:	2301      	movs	r3, #1
 4e4:	4619      	mov	r1, r3
 4e6:	f500 6082 	add.w	r0, r0, #1040	; 0x410
 4ea:	f7ff ff32 	bl	352 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0>
    Nvic::activateInterrupt((interrupt)((((gpioPort) == 5) ? 30 : (gpioPort))), (*this).interruptPriority);
 4ee:	6963      	ldr	r3, [r4, #20]
 4f0:	68a1      	ldr	r1, [r4, #8]
 4f2:	2b05      	cmp	r3, #5
 4f4:	d11d      	bne.n	532 <_ZN4Gpio10initializeEm9directionm.constprop.0+0xa2>
 4f6:	241e      	movs	r4, #30
    if((myInterrupt < 139) && (priority < 8))
 4f8:	2907      	cmp	r1, #7
 4fa:	d81d      	bhi.n	538 <_ZN4Gpio10initializeEm9directionm.constprop.0+0xa8>
        Register::setRegisterBitFieldStatus(((volatile uint32_t*)(corePeripheralBase + PRIn_OFFSET[myInterrupt/4])), priority, ((myInterrupt % nvicRegisterOffset) * 8) + 5, 3, RW);
 4fc:	08a0      	lsrs	r0, r4, #2
 4fe:	4b0f      	ldr	r3, [pc, #60]	; (53c <_ZN4Gpio10initializeEm9directionm.constprop.0+0xac>)
 500:	f004 0203 	and.w	r2, r4, #3
 504:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 508:	00d2      	lsls	r2, r2, #3
 50a:	2303      	movs	r3, #3
 50c:	3205      	adds	r2, #5
 50e:	f100 20e0 	add.w	r0, r0, #3758153728	; 0xe000e000
 512:	f7ff ff1e 	bl	352 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0>
        Register::setRegisterBitFieldStatus(((volatile uint32_t*)(corePeripheralBase + ENn_OFFSET[myInterrupt/32])), (uint32_t)set, (uint32_t)(myInterrupt % 32), 1, RW);
 516:	0962      	lsrs	r2, r4, #5
 518:	4b09      	ldr	r3, [pc, #36]	; (540 <_ZN4Gpio10initializeEm9directionm.constprop.0+0xb0>)
 51a:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
 51e:	2301      	movs	r3, #1
 520:	f004 021f 	and.w	r2, r4, #31
 524:	4619      	mov	r1, r3
 526:	f100 20e0 	add.w	r0, r0, #3758153728	; 0xe000e000
}
 52a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 52e:	f7ff bf10 	b.w	352 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0>
    Nvic::activateInterrupt((interrupt)((((gpioPort) == 5) ? 30 : (gpioPort))), (*this).interruptPriority);
 532:	b2dc      	uxtb	r4, r3
    if((myInterrupt < 139) && (priority < 8))
 534:	2c8a      	cmp	r4, #138	; 0x8a
 536:	d9df      	bls.n	4f8 <_ZN4Gpio10initializeEm9directionm.constprop.0+0x68>
}
 538:	bd10      	pop	{r4, pc}
 53a:	bf00      	nop
 53c:	00000894 	.word	0x00000894
 540:	00000880 	.word	0x00000880

00000544 <_ZN4GpioD1Ev>:
}
 544:	4770      	bx	lr
	...

00000548 <_GLOBAL__sub_I_greenLed>:
    while(1)
    {
        Nvic::wfi();
    }

}
 548:	b570      	push	{r4, r5, r6, lr}
Gpio greenLed;
 54a:	4c14      	ldr	r4, [pc, #80]	; (59c <_GLOBAL__sub_I_greenLed+0x54>)
 54c:	4d14      	ldr	r5, [pc, #80]	; (5a0 <_GLOBAL__sub_I_greenLed+0x58>)
Gpio::Gpio()
 54e:	4815      	ldr	r0, [pc, #84]	; (5a4 <_GLOBAL__sub_I_greenLed+0x5c>)
 550:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
 554:	4622      	mov	r2, r4
 556:	4629      	mov	r1, r5
 558:	60c6      	str	r6, [r0, #12]
 55a:	f000 f971 	bl	840 <__aeabi_atexit>
 55e:	4812      	ldr	r0, [pc, #72]	; (5a8 <_GLOBAL__sub_I_greenLed+0x60>)
Gpio blueLed;
 560:	4622      	mov	r2, r4
 562:	4629      	mov	r1, r5
 564:	60c6      	str	r6, [r0, #12]
 566:	f000 f96b 	bl	840 <__aeabi_atexit>
 56a:	4810      	ldr	r0, [pc, #64]	; (5ac <_GLOBAL__sub_I_greenLed+0x64>)
Gpio redLed;
 56c:	4622      	mov	r2, r4
 56e:	4629      	mov	r1, r5
 570:	60c6      	str	r6, [r0, #12]
 572:	f000 f965 	bl	840 <__aeabi_atexit>
 576:	480e      	ldr	r0, [pc, #56]	; (5b0 <_GLOBAL__sub_I_greenLed+0x68>)
Gpio swtich1;
 578:	4622      	mov	r2, r4
 57a:	4629      	mov	r1, r5
 57c:	60c6      	str	r6, [r0, #12]
 57e:	f000 f95f 	bl	840 <__aeabi_atexit>
 582:	480c      	ldr	r0, [pc, #48]	; (5b4 <_GLOBAL__sub_I_greenLed+0x6c>)
Gpio swtich2;
 584:	4622      	mov	r2, r4
 586:	4629      	mov	r1, r5
 588:	60c6      	str	r6, [r0, #12]
 58a:	f000 f959 	bl	840 <__aeabi_atexit>
Pwm greenPwm;
 58e:	4622      	mov	r2, r4
 590:	4909      	ldr	r1, [pc, #36]	; (5b8 <_GLOBAL__sub_I_greenLed+0x70>)
 592:	480a      	ldr	r0, [pc, #40]	; (5bc <_GLOBAL__sub_I_greenLed+0x74>)
}
 594:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
Pwm greenPwm;
 598:	f000 b952 	b.w	840 <__aeabi_atexit>
 59c:	20000000 	.word	0x20000000
 5a0:	00000545 	.word	0x00000545
 5a4:	20000044 	.word	0x20000044
 5a8:	2000002c 	.word	0x2000002c
 5ac:	20000060 	.word	0x20000060
 5b0:	20000078 	.word	0x20000078
 5b4:	20000090 	.word	0x20000090
 5b8:	0000033d 	.word	0x0000033d
 5bc:	2000005c 	.word	0x2000005c

000005c0 <main>:
{
 5c0:	b508      	push	{r3, lr}
    Nvic::disableInterrupts();
 5c2:	f7ff fe95 	bl	2f0 <_ZN4Nvic17disableInterruptsEv>
    swtich1.initialize((uint32_t)PF4::GPIO, input, 3);
 5c6:	f241 1130 	movw	r1, #4400	; 0x1130
 5ca:	480a      	ldr	r0, [pc, #40]	; (5f4 <main+0x34>)
 5cc:	f7ff ff60 	bl	490 <_ZN4Gpio10initializeEm9directionm.constprop.0>
    swtich2.initialize((uint32_t)PF0::GPIO, input, 3);
 5d0:	f44f 617a 	mov.w	r1, #4000	; 0xfa0
 5d4:	4808      	ldr	r0, [pc, #32]	; (5f8 <main+0x38>)
 5d6:	f7ff ff5b 	bl	490 <_ZN4Gpio10initializeEm9directionm.constprop.0>
    Nvic::enableInterrupts();
 5da:	f7ff fe98 	bl	30e <_ZN4Nvic16enableInterruptsEv>
    if((value == 0x0) || (value == 0x1))
 5de:	2101      	movs	r1, #1
 5e0:	4806      	ldr	r0, [pc, #24]	; (5fc <main+0x3c>)
 5e2:	f7ff fec8 	bl	376 <_ZN4Gpio5writeE10setORClear.part.0>
 5e6:	2101      	movs	r1, #1
 5e8:	4805      	ldr	r0, [pc, #20]	; (600 <main+0x40>)
 5ea:	f7ff fec4 	bl	376 <_ZN4Gpio5writeE10setORClear.part.0>
        Nvic::wfi();
 5ee:	f7ff fe9d 	bl	32c <_ZN4Nvic3wfiEv>
 5f2:	e7fc      	b.n	5ee <main+0x2e>
 5f4:	20000078 	.word	0x20000078
 5f8:	20000090 	.word	0x20000090
 5fc:	2000002c 	.word	0x2000002c
 600:	20000060 	.word	0x20000060

00000604 <SystemInit>:
            (*address) &= clear;
 604:	4b64      	ldr	r3, [pc, #400]	; (798 <SystemInit+0x194>)
 606:	681a      	ldr	r2, [r3, #0]
 608:	f022 0201 	bic.w	r2, r2, #1
{
 60c:	b570      	push	{r4, r5, r6, lr}
 60e:	601a      	str	r2, [r3, #0]
            (*address) |= value;
 610:	681a      	ldr	r2, [r3, #0]
            (*address) &= clear;
 612:	4c62      	ldr	r4, [pc, #392]	; (79c <SystemInit+0x198>)
            (*address) |= value;
 614:	f042 0201 	orr.w	r2, r2, #1
 618:	601a      	str	r2, [r3, #0]
            (*address) &= clear;
 61a:	681a      	ldr	r2, [r3, #0]
 61c:	f022 0202 	bic.w	r2, r2, #2
 620:	601a      	str	r2, [r3, #0]
            (*address) |= value;
 622:	681a      	ldr	r2, [r3, #0]
 624:	f042 0202 	orr.w	r2, r2, #2
 628:	601a      	str	r2, [r3, #0]
            (*address) &= clear;
 62a:	681a      	ldr	r2, [r3, #0]
 62c:	f022 0204 	bic.w	r2, r2, #4
 630:	601a      	str	r2, [r3, #0]
            (*address) |= value;
 632:	681a      	ldr	r2, [r3, #0]
 634:	f042 0204 	orr.w	r2, r2, #4
 638:	601a      	str	r2, [r3, #0]
            (*address) &= clear;
 63a:	681a      	ldr	r2, [r3, #0]
 63c:	f022 0208 	bic.w	r2, r2, #8
 640:	601a      	str	r2, [r3, #0]
            (*address) |= value;
 642:	681a      	ldr	r2, [r3, #0]
 644:	f042 0208 	orr.w	r2, r2, #8
 648:	601a      	str	r2, [r3, #0]
            (*address) &= clear;
 64a:	681a      	ldr	r2, [r3, #0]
 64c:	f022 0210 	bic.w	r2, r2, #16
 650:	601a      	str	r2, [r3, #0]
            (*address) |= value;
 652:	681a      	ldr	r2, [r3, #0]
 654:	f042 0210 	orr.w	r2, r2, #16
 658:	601a      	str	r2, [r3, #0]
            (*address) &= clear;
 65a:	681a      	ldr	r2, [r3, #0]
 65c:	f022 0220 	bic.w	r2, r2, #32
 660:	601a      	str	r2, [r3, #0]
            (*address) |= value;
 662:	681a      	ldr	r2, [r3, #0]
 664:	f042 0220 	orr.w	r2, r2, #32
 668:	601a      	str	r2, [r3, #0]
            (*address) &= clear;
 66a:	6823      	ldr	r3, [r4, #0]
 66c:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 670:	6023      	str	r3, [r4, #0]
            (*address) |= value;
 672:	6823      	ldr	r3, [r4, #0]
 674:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 678:	6023      	str	r3, [r4, #0]
            (*address) &= clear;
 67a:	6823      	ldr	r3, [r4, #0]
 67c:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 680:	6023      	str	r3, [r4, #0]
            (*address) |= value;
 682:	6823      	ldr	r3, [r4, #0]
 684:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 688:	6023      	str	r3, [r4, #0]
            (*address) &= clear;
 68a:	4b45      	ldr	r3, [pc, #276]	; (7a0 <SystemInit+0x19c>)
 68c:	681a      	ldr	r2, [r3, #0]
 68e:	f422 62f8 	bic.w	r2, r2, #1984	; 0x7c0
 692:	601a      	str	r2, [r3, #0]
            (*address) |= value;
 694:	681a      	ldr	r2, [r3, #0]
 696:	f442 62a8 	orr.w	r2, r2, #1344	; 0x540
 69a:	601a      	str	r2, [r3, #0]
            (*address) &= clear;
 69c:	6823      	ldr	r3, [r4, #0]
 69e:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 6a2:	6023      	str	r3, [r4, #0]
            (*address) |= value;
 6a4:	6823      	ldr	r3, [r4, #0]
 6a6:	6023      	str	r3, [r4, #0]
            (*address) &= clear;
 6a8:	6823      	ldr	r3, [r4, #0]
 6aa:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 6ae:	6023      	str	r3, [r4, #0]
            (*address) |= value;
 6b0:	6823      	ldr	r3, [r4, #0]
 6b2:	6023      	str	r3, [r4, #0]
            (*address) &= clear;
 6b4:	6823      	ldr	r3, [r4, #0]
 6b6:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 6ba:	6023      	str	r3, [r4, #0]
            (*address) |= value;
 6bc:	6823      	ldr	r3, [r4, #0]
 6be:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 6c2:	6023      	str	r3, [r4, #0]
void Register::setRegisterBitFieldStatus(volatile uint32_t* address, uint32_t value, uint32_t bit, uint32_t bitWidth, bitFieldPermission permission)
 6c4:	2216      	movs	r2, #22
 6c6:	2301      	movs	r3, #1
 6c8:	2100      	movs	r1, #0
 6ca:	4620      	mov	r0, r4
 6cc:	f7ff fe41 	bl	352 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0>
 6d0:	2217      	movs	r2, #23
 6d2:	2306      	movs	r3, #6
 6d4:	2102      	movs	r1, #2
 6d6:	f7ff fe3c 	bl	352 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0>
        return(((*address) & select) >> bit);
 6da:	4a32      	ldr	r2, [pc, #200]	; (7a4 <SystemInit+0x1a0>)
 6dc:	6813      	ldr	r3, [r2, #0]
	Register::setRegisterBitFieldStatus(((volatile uint32_t*)(systemControlBase + RCC2_OFFSET)), set, 30, 1, RW);
	
	Register::setRegisterBitFieldStatus(((volatile uint32_t*)(systemControlBase + RCC2_OFFSET)), ((frequency - 1) & 0x01), 22, 1, RW);
	Register::setRegisterBitFieldStatus(((volatile uint32_t*)(systemControlBase + RCC2_OFFSET)), ((frequency - 1) >> 1), 23, 6, RW);

	while((Register::getRegisterBitFieldStatus(((volatile uint32_t*)(systemControlBase + RIS_OFFSET)), 6, 1, RO)) == 0)  // 5. Wait for the PLL to lock by polling PLLRIS.
 6de:	0659      	lsls	r1, r3, #25
 6e0:	d5fc      	bpl.n	6dc <SystemInit+0xd8>
            (*address) &= clear;
 6e2:	6823      	ldr	r3, [r4, #0]
    greenLed.initialize((uint32_t)PF3::M1PWM7, output);
 6e4:	4830      	ldr	r0, [pc, #192]	; (7a8 <SystemInit+0x1a4>)
 6e6:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 6ea:	6023      	str	r3, [r4, #0]
            (*address) |= value;
 6ec:	6823      	ldr	r3, [r4, #0]
 6ee:	6023      	str	r3, [r4, #0]
 6f0:	2201      	movs	r2, #1
 6f2:	f241 01d2 	movw	r1, #4306	; 0x10d2
 6f6:	f7ff fe53 	bl	3a0 <_ZN4Gpio10initializeEm9direction>
    blueLed.initialize((uint32_t)PF2::GPIO, output);
 6fa:	2201      	movs	r2, #1
 6fc:	f241 0168 	movw	r1, #4200	; 0x1068
 700:	482a      	ldr	r0, [pc, #168]	; (7ac <SystemInit+0x1a8>)

void Pwm::initialize(pwmGenerator myPwmGen, pwmModule module, uint32_t period, countDirectionPwm countDir, bool enablePwmDiv, uint32_t divisor)
{
    countDir = countDir;
    
    baseAddress = pwm0BaseAddress + (module * 0x1000);
 702:	4c2b      	ldr	r4, [pc, #172]	; (7b0 <SystemInit+0x1ac>)
 704:	f7ff fe4c 	bl	3a0 <_ZN4Gpio10initializeEm9direction>
    redLed.initialize((uint32_t)PF1::GPIO, output);
 708:	2201      	movs	r2, #1
 70a:	f241 0104 	movw	r1, #4100	; 0x1004
 70e:	4829      	ldr	r0, [pc, #164]	; (7b4 <SystemInit+0x1b0>)
 710:	f7ff fe46 	bl	3a0 <_ZN4Gpio10initializeEm9direction>
 714:	4b28      	ldr	r3, [pc, #160]	; (7b8 <SystemInit+0x1b4>)
 716:	6023      	str	r3, [r4, #0]
void Register::setRegisterBitFieldStatus(volatile uint32_t* address, uint32_t value, uint32_t bit, uint32_t bitWidth, bitFieldPermission permission)
 718:	2301      	movs	r3, #1
 71a:	461a      	mov	r2, r3
 71c:	4619      	mov	r1, r3
 71e:	4827      	ldr	r0, [pc, #156]	; (7bc <SystemInit+0x1b8>)
 720:	f7ff fe17 	bl	352 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0>
        return(((*address) & select) >> bit);
 724:	4a26      	ldr	r2, [pc, #152]	; (7c0 <SystemInit+0x1bc>)
 726:	6813      	ldr	r3, [r2, #0]
    
    //0. Enable the clock for PWM
    Register::setRegisterBitFieldStatus(((volatile uint32_t*)(systemControlBase + RCGCPWM_OFFSET)), set, module, 1, RW);
    while(Register::getRegisterBitFieldStatus((volatile uint32_t*)(systemControlBase + PRPWM_OFFSET), module, 1, RO) == 0)
 728:	079b      	lsls	r3, r3, #30
 72a:	d5fc      	bpl.n	726 <SystemInit+0x122>
    }

    //2. Configure the PWM generator for countdown mode with immediate updates to the parameters.

    //2a. Write the PWMnCTL register with a value of 0x0000.0000 to clear it.
    Register::setRegisterBitFieldStatus((volatile uint32_t*)(baseAddress + (PWM0CTL_OFFSET + (0x40 * myPwmGen))), 0x00000, 0, 18+1, RW);
 72c:	6823      	ldr	r3, [r4, #0]
            (*address) &= clear;
 72e:	4d25      	ldr	r5, [pc, #148]	; (7c4 <SystemInit+0x1c0>)
 730:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
 734:	4824      	ldr	r0, [pc, #144]	; (7c8 <SystemInit+0x1c4>)
 736:	402a      	ands	r2, r5
 738:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
            (*address) |= value;
 73c:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
 740:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
    Register::setRegisterBitFieldStatus((volatile uint32_t*)(baseAddress + (PWM0GENA_OFFSET + (0x40 * myPwmGen) + (uint32_t)output)), genOptions, 0, 11+1, RW);
 744:	6822      	ldr	r2, [r4, #0]
            (*address) &= clear;
 746:	f8d2 3120 	ldr.w	r3, [r2, #288]	; 0x120
 74a:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 74e:	f023 030f 	bic.w	r3, r3, #15
 752:	f8c2 3120 	str.w	r3, [r2, #288]	; 0x120
            (*address) |= value;
 756:	f8d2 3120 	ldr.w	r3, [r2, #288]	; 0x120
 75a:	f043 038c 	orr.w	r3, r3, #140	; 0x8c
 75e:	f8c2 3120 	str.w	r3, [r2, #288]	; 0x120
void Register::setRegisterBitFieldStatus(volatile uint32_t* address, uint32_t value, uint32_t bit, uint32_t bitWidth, bitFieldPermission permission)
 762:	2301      	movs	r3, #1
 764:	461a      	mov	r2, r3
 766:	4619      	mov	r1, r3
 768:	f7ff fdf3 	bl	352 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0>
    Register::setRegisterBitFieldStatus((volatile uint32_t*)(baseAddress + (PWM0CTL_OFFSET + (0x40 * myPwmGen))), 0x00001, 0, 18+1, RW);
 76c:	6823      	ldr	r3, [r4, #0]
            (*address) &= clear;
 76e:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
 772:	402a      	ands	r2, r5
 774:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
            (*address) |= value;
 778:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
 77c:	f042 0201 	orr.w	r2, r2, #1
 780:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
    Register::setRegisterBitFieldStatus((volatile uint32_t*)(baseAddress + (PWMENABLE_OFFSET + (0x40 * myPwmGen))), 0x1, 0 + ((myPwmGen*2)+(((uint32_t)output)/4)), 1, RW); //(uint32_t)output >> 2
 784:	6820      	ldr	r0, [r4, #0]
 786:	2301      	movs	r3, #1
 788:	2206      	movs	r2, #6
 78a:	4619      	mov	r1, r3
 78c:	30c8      	adds	r0, #200	; 0xc8
}
 78e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 792:	f7ff bdde 	b.w	352 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0>
 796:	bf00      	nop
 798:	400fe06c 	.word	0x400fe06c
 79c:	400fe070 	.word	0x400fe070
 7a0:	400fe060 	.word	0x400fe060
 7a4:	400fe050 	.word	0x400fe050
 7a8:	20000044 	.word	0x20000044
 7ac:	2000002c 	.word	0x2000002c
 7b0:	2000005c 	.word	0x2000005c
 7b4:	20000060 	.word	0x20000060
 7b8:	40029000 	.word	0x40029000
 7bc:	400fe640 	.word	0x400fe640
 7c0:	400fea40 	.word	0x400fea40
 7c4:	fff80000 	.word	0xfff80000
 7c8:	400fe540 	.word	0x400fe540

000007cc <GPIO_Port_F_Handler>:
{
 7cc:	b508      	push	{r3, lr}
    if(swtich1.read() == 1)
 7ce:	4818      	ldr	r0, [pc, #96]	; (830 <GPIO_Port_F_Handler+0x64>)
 7d0:	f7ff fdb5 	bl	33e <_ZN4Gpio4readEv>
 7d4:	2801      	cmp	r0, #1
 7d6:	d106      	bne.n	7e6 <GPIO_Port_F_Handler+0x1a>
 7d8:	4816      	ldr	r0, [pc, #88]	; (834 <GPIO_Port_F_Handler+0x68>)
 7da:	2100      	movs	r1, #0
 7dc:	f7ff fdcb 	bl	376 <_ZN4Gpio5writeE10setORClear.part.0>
        swtich1.interruptClear();
 7e0:	4813      	ldr	r0, [pc, #76]	; (830 <GPIO_Port_F_Handler+0x64>)
 7e2:	f7ff fdd2 	bl	38a <_ZN4Gpio14interruptClearEv>
    if(swtich1.read() == 0)
 7e6:	4812      	ldr	r0, [pc, #72]	; (830 <GPIO_Port_F_Handler+0x64>)
 7e8:	f7ff fda9 	bl	33e <_ZN4Gpio4readEv>
 7ec:	b930      	cbnz	r0, 7fc <GPIO_Port_F_Handler+0x30>
 7ee:	4811      	ldr	r0, [pc, #68]	; (834 <GPIO_Port_F_Handler+0x68>)
 7f0:	2101      	movs	r1, #1
 7f2:	f7ff fdc0 	bl	376 <_ZN4Gpio5writeE10setORClear.part.0>
        swtich1.interruptClear();
 7f6:	480e      	ldr	r0, [pc, #56]	; (830 <GPIO_Port_F_Handler+0x64>)
 7f8:	f7ff fdc7 	bl	38a <_ZN4Gpio14interruptClearEv>
    if(swtich2.read() == 1)
 7fc:	480e      	ldr	r0, [pc, #56]	; (838 <GPIO_Port_F_Handler+0x6c>)
 7fe:	f7ff fd9e 	bl	33e <_ZN4Gpio4readEv>
 802:	2801      	cmp	r0, #1
 804:	d106      	bne.n	814 <GPIO_Port_F_Handler+0x48>
 806:	480d      	ldr	r0, [pc, #52]	; (83c <GPIO_Port_F_Handler+0x70>)
 808:	2100      	movs	r1, #0
 80a:	f7ff fdb4 	bl	376 <_ZN4Gpio5writeE10setORClear.part.0>
        swtich2.interruptClear();
 80e:	480a      	ldr	r0, [pc, #40]	; (838 <GPIO_Port_F_Handler+0x6c>)
 810:	f7ff fdbb 	bl	38a <_ZN4Gpio14interruptClearEv>
    if(swtich2.read() == 0)
 814:	4808      	ldr	r0, [pc, #32]	; (838 <GPIO_Port_F_Handler+0x6c>)
 816:	f7ff fd92 	bl	33e <_ZN4Gpio4readEv>
 81a:	b940      	cbnz	r0, 82e <GPIO_Port_F_Handler+0x62>
 81c:	4807      	ldr	r0, [pc, #28]	; (83c <GPIO_Port_F_Handler+0x70>)
 81e:	2101      	movs	r1, #1
 820:	f7ff fda9 	bl	376 <_ZN4Gpio5writeE10setORClear.part.0>
        swtich2.interruptClear();
 824:	4804      	ldr	r0, [pc, #16]	; (838 <GPIO_Port_F_Handler+0x6c>)
}
 826:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        swtich2.interruptClear();
 82a:	f7ff bdae 	b.w	38a <_ZN4Gpio14interruptClearEv>
}
 82e:	bd08      	pop	{r3, pc}
 830:	20000078 	.word	0x20000078
 834:	20000060 	.word	0x20000060
 838:	20000090 	.word	0x20000090
 83c:	2000002c 	.word	0x2000002c

00000840 <__aeabi_atexit>:
 840:	460b      	mov	r3, r1
 842:	4601      	mov	r1, r0
 844:	4618      	mov	r0, r3
 846:	f000 b801 	b.w	84c <__cxa_atexit>
	...

0000084c <__cxa_atexit>:
 84c:	b510      	push	{r4, lr}
 84e:	4c05      	ldr	r4, [pc, #20]	; (864 <__cxa_atexit+0x18>)
 850:	4613      	mov	r3, r2
 852:	b12c      	cbz	r4, 860 <__cxa_atexit+0x14>
 854:	460a      	mov	r2, r1
 856:	4601      	mov	r1, r0
 858:	2002      	movs	r0, #2
 85a:	f3af 8000 	nop.w
 85e:	bd10      	pop	{r4, pc}
 860:	4620      	mov	r0, r4
 862:	e7fc      	b.n	85e <__cxa_atexit+0x12>
 864:	00000000 	.word	0x00000000

00000868 <_init>:
 868:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 86a:	bf00      	nop
 86c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 86e:	bc08      	pop	{r3}
 870:	469e      	mov	lr, r3
 872:	4770      	bx	lr

00000874 <_fini>:
 874:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 876:	bf00      	nop
 878:	bcf8      	pop	{r3, r4, r5, r6, r7}
 87a:	bc08      	pop	{r3}
 87c:	469e      	mov	lr, r3
 87e:	4770      	bx	lr

00000880 <_ZN4Nvic10ENn_OFFSETE>:
 880:	0100 0000 0104 0000 0108 0000 010c 0000     ................
 890:	0110 0000                                   ....

00000894 <_ZN4Nvic11PRIn_OFFSETE>:
 894:	0400 0000 0404 0000 0408 0000 040c 0000     ................
 8a4:	040c 0000 0414 0000 0418 0000 041c 0000     ................
 8b4:	0420 0000 0424 0000 0428 0000 042c 0000      ...$...(...,...
 8c4:	0430 0000 0434 0000 0438 0000 043c 0000     0...4...8...<...
 8d4:	0440 0000 0444 0000 0448 0000 044c 0000     @...D...H...L...
 8e4:	0450 0000 0454 0000 0458 0000 045c 0000     P...T...X...\...
 8f4:	0460 0000 0464 0000 0468 0000 046c 0000     `...d...h...l...
 904:	0470 0000 0474 0000 0478 0000 047c 0000     p...t...x...|...
 914:	0480 0000 0484 0000 0488 0000               ............

00000920 <__EH_FRAME_BEGIN__>:
 920:	0000 0000                                   ....
