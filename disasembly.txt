
main.elf:     file format elf32-littlearm


Disassembly of section .text:

00000000 <__isr_vector>:
   0:	00 80 00 20 ad 02 00 00 ed 02 00 00 ed 02 00 00     ... ............
  10:	ed 02 00 00 ed 02 00 00 ed 02 00 00 00 00 00 00     ................
	...
  2c:	ed 02 00 00 ed 02 00 00 00 00 00 00 ed 02 00 00     ................
  3c:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
  4c:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
  5c:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
  6c:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
  7c:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
  8c:	8d 07 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
  9c:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
  ac:	00 00 00 00 ed 02 00 00 ed 02 00 00 c9 07 00 00     ................
	...
  c4:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
  d4:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
	...
  ec:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
  fc:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
 10c:	ed 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
 124:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
 134:	ed 02 00 00 ed 02 00 00 ed 02 00 00 00 00 00 00     ................
	...
 150:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
	...
 1b0:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
 1c0:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
 1d0:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
 1e0:	ed 02 00 00 ed 02 00 00 ed 02 00 00 00 00 00 00     ................
	...
 258:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
 268:	ed 02 00 00                                         ....

0000026c <__do_global_dtors_aux>:
 26c:	b510      	push	{r4, lr}
 26e:	4c05      	ldr	r4, [pc, #20]	; (284 <__do_global_dtors_aux+0x18>)
 270:	7823      	ldrb	r3, [r4, #0]
 272:	b933      	cbnz	r3, 282 <__do_global_dtors_aux+0x16>
 274:	4b04      	ldr	r3, [pc, #16]	; (288 <__do_global_dtors_aux+0x1c>)
 276:	b113      	cbz	r3, 27e <__do_global_dtors_aux+0x12>
 278:	4804      	ldr	r0, [pc, #16]	; (28c <__do_global_dtors_aux+0x20>)
 27a:	f3af 8000 	nop.w
 27e:	2301      	movs	r3, #1
 280:	7023      	strb	r3, [r4, #0]
 282:	bd10      	pop	{r4, pc}
 284:	20000070 	.word	0x20000070
 288:	00000000 	.word	0x00000000
 28c:	00000ab8 	.word	0x00000ab8

00000290 <frame_dummy>:
 290:	b508      	push	{r3, lr}
 292:	4b03      	ldr	r3, [pc, #12]	; (2a0 <frame_dummy+0x10>)
 294:	b11b      	cbz	r3, 29e <frame_dummy+0xe>
 296:	4903      	ldr	r1, [pc, #12]	; (2a4 <frame_dummy+0x14>)
 298:	4803      	ldr	r0, [pc, #12]	; (2a8 <frame_dummy+0x18>)
 29a:	f3af 8000 	nop.w
 29e:	bd08      	pop	{r3, pc}
 2a0:	00000000 	.word	0x00000000
 2a4:	20000074 	.word	0x20000074
 2a8:	00000ab8 	.word	0x00000ab8

000002ac <Reset_Handler>:
 *    __data_start__: VMA of start of the section to copy to
 *    __data_end__: VMA of end of the section to copy to
 *
 *  All addresses must be aligned to 4 bytes boundary.
 */
	ldr	r1, =__etext
 2ac:	490a      	ldr	r1, [pc, #40]	; (2d8 <Reset_Handler+0x2c>)
	ldr	r2, =__data_start__
 2ae:	4a0b      	ldr	r2, [pc, #44]	; (2dc <Reset_Handler+0x30>)
	ldr	r3, =__data_end__
 2b0:	4b0b      	ldr	r3, [pc, #44]	; (2e0 <Reset_Handler+0x34>)

.L_loop1:
	cmp	r2, r3
 2b2:	429a      	cmp	r2, r3
	ittt	lt
 2b4:	bfbe      	ittt	lt
	ldrlt	r0, [r1], #4
 2b6:	f851 0b04 	ldrlt.w	r0, [r1], #4
	strlt	r0, [r2], #4
 2ba:	f842 0b04 	strlt.w	r0, [r2], #4
	blt	.L_loop1
 2be:	e7f8      	blt.n	2b2 <Reset_Handler+0x6>
 *    __bss_start__: start of the BSS section.
 *    __bss_end__: end of the BSS section.
 *
 *  Both addresses must be aligned to 4 bytes boundary.
 */
	ldr	r1, =__bss_start__
 2c0:	4908      	ldr	r1, [pc, #32]	; (2e4 <Reset_Handler+0x38>)
	ldr	r2, =__bss_end__
 2c2:	4a09      	ldr	r2, [pc, #36]	; (2e8 <Reset_Handler+0x3c>)

	movs	r0, 0
 2c4:	2000      	movs	r0, #0
.L_loop3:
	cmp	r1, r2
 2c6:	4291      	cmp	r1, r2
	itt	lt
 2c8:	bfbc      	itt	lt
	strlt	r0, [r1], #4
 2ca:	f841 0b04 	strlt.w	r0, [r1], #4
	blt	.L_loop3
 2ce:	e7fa      	blt.n	2c6 <Reset_Handler+0x1a>
#endif /* __STARTUP_CLEAR_BSS_MULTIPLE || __STARTUP_CLEAR_BSS */

#ifndef __NO_SYSTEM_INIT
	bl	SystemInit
 2d0:	f000 f9ba 	bl	648 <SystemInit>
#endif

#ifndef __START
#define __START _start
#endif
	bl	__START
 2d4:	f000 f92a 	bl	52c <main>
	ldr	r1, =__etext
 2d8:	00000abc 	.word	0x00000abc
	ldr	r2, =__data_start__
 2dc:	20000000 	.word	0x20000000
	ldr	r3, =__data_end__
 2e0:	20000070 	.word	0x20000070
	ldr	r1, =__bss_start__
 2e4:	20000070 	.word	0x20000070
	ldr	r2, =__bss_end__
 2e8:	200000c0 	.word	0x200000c0

000002ec <ADC_0_Sequence_0_Handler>:
	.align	1
	.thumb_func
	.weak	Default_Handler
	.type	Default_Handler, %function
Default_Handler:
	b	.
 2ec:	e7fe      	b.n	2ec <ADC_0_Sequence_0_Handler>
 2ee:	bf00      	nop

000002f0 <_ZN4Nvic17disableInterruptsEv>:
}

#pragma GCC push_options
#pragma GCC optimize("O0")
uint32_t Nvic::disableInterrupts(void)
{
 2f0:	b480      	push	{r7}
 2f2:	b083      	sub	sp, #12
 2f4:	af00      	add	r7, sp, #0

        "mrs     r0, PRIMASK\n"
        "cpsid   i\n"
        "bx      lr\n"
        : "=r" (ui32Ret)
    );
 2f6:	f3ef 8010 	mrs	r0, PRIMASK
 2fa:	b672      	cpsid	i
 2fc:	4770      	bx	lr
 2fe:	607b      	str	r3, [r7, #4]

    return(ui32Ret);
 300:	687b      	ldr	r3, [r7, #4]
}
 302:	4618      	mov	r0, r3
 304:	370c      	adds	r7, #12
 306:	46bd      	mov	sp, r7
 308:	f85d 7b04 	ldr.w	r7, [sp], #4
 30c:	4770      	bx	lr

0000030e <_ZN4Nvic16enableInterruptsEv>:


#pragma GCC push_options
#pragma GCC optimize("O0")
uint32_t Nvic::enableInterrupts(void)
{
 30e:	b480      	push	{r7}
 310:	b083      	sub	sp, #12
 312:	af00      	add	r7, sp, #0

        "mrs     r0, PRIMASK\n"
        "cpsie   i\n"
        "bx      lr\n"
        : "=r" (ui32Ret)
    );
 314:	f3ef 8010 	mrs	r0, PRIMASK
 318:	b662      	cpsie	i
 31a:	4770      	bx	lr
 31c:	607b      	str	r3, [r7, #4]

    return(ui32Ret);
 31e:	687b      	ldr	r3, [r7, #4]
}
 320:	4618      	mov	r0, r3
 322:	370c      	adds	r7, #12
 324:	46bd      	mov	sp, r7
 326:	f85d 7b04 	ldr.w	r7, [sp], #4
 32a:	4770      	bx	lr

0000032c <_ZN4Nvic3wfiEv>:


#pragma GCC push_options
#pragma GCC optimize("O0")
void Nvic::wfi(void)
{
 32c:	b480      	push	{r7}
 32e:	af00      	add	r7, sp, #0
    //
    asm volatile(

        "wfi     \n"
        "bx    lr\n"
    );
 330:	bf30      	wfi
 332:	4770      	bx	lr
    
}
 334:	46bd      	mov	sp, r7
 336:	f85d 7b04 	ldr.w	r7, [sp], #4
 33a:	4770      	bx	lr

0000033c <_ZN4Gpio8gpioReadEv>:
    }
}

uint32_t Gpio::gpioRead(void)
{
    return((Register::getRegisterBitFieldStatus(((volatile uint32_t*)(gpioBaseAddress + GPIODATA_OFFSET)), gpioPin, 1, RW)));
 33c:	e9d0 3001 	ldrd	r3, r0, [r0, #4]
uint32_t Register::getRegisterBitFieldStatus(volatile uint32_t* address, uint32_t bit, uint32_t bitWidth, bitFieldPermission permission)
{
    if((permission == RW) || (permission == RO) || (permission == RW1C))
    {
        uint32_t select = ((((0xFFFFFFFF >> (32 - bitWidth)))) << bit);
        return(((*address) & select) >> bit);
 340:	f8d3 23fc 	ldr.w	r2, [r3, #1020]	; 0x3fc
        uint32_t select = ((((0xFFFFFFFF >> (32 - bitWidth)))) << bit);
 344:	2301      	movs	r3, #1
 346:	4083      	lsls	r3, r0
        return(((*address) & select) >> bit);
 348:	4013      	ands	r3, r2
 34a:	fa23 f000 	lsr.w	r0, r3, r0
 34e:	4770      	bx	lr

00000350 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0>:
    {
        return(UINT32_MAX);
    }
}

void Register::setRegisterBitFieldStatus(volatile uint32_t* address, uint32_t value, uint32_t bit, uint32_t bitWidth, bitFieldPermission permission)
 350:	b510      	push	{r4, lr}
        return;
    }
    
    else if((permission == RW) || (permission == WO) || (permission == RW1C))
    {
        uint32_t maxValue = (0xFFFFFFFF >> (32 - bitWidth));
 352:	f1c3 0420 	rsb	r4, r3, #32
 356:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 35a:	40e3      	lsrs	r3, r4

        if((value <= maxValue))
 35c:	428b      	cmp	r3, r1
 35e:	d308      	bcc.n	372 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0+0x22>
        {
            uint32_t clear = (~(maxValue << bit));
            value = value << bit;
    
            (*address) &= clear;
 360:	6804      	ldr	r4, [r0, #0]
            uint32_t clear = (~(maxValue << bit));
 362:	4093      	lsls	r3, r2
            (*address) &= clear;
 364:	ea24 0303 	bic.w	r3, r4, r3
 368:	6003      	str	r3, [r0, #0]
            (*address) |= value;
 36a:	6803      	ldr	r3, [r0, #0]
            value = value << bit;
 36c:	4091      	lsls	r1, r2
            (*address) |= value;
 36e:	4319      	orrs	r1, r3
 370:	6001      	str	r1, [r0, #0]

    else
    {
        return;
    }
}
 372:	bd10      	pop	{r4, pc}

00000374 <_ZN4Nvic17activateInterruptE9interruptm.part.0.constprop.4>:
        Register::setRegisterBitFieldStatus(((volatile uint32_t*)(corePeripheralBase + PRIn_OFFSET[myInterrupt/4])), priority, ((myInterrupt % nvicRegisterOffset) * 8) + 5, 3, RW);
 374:	0881      	lsrs	r1, r0, #2
 376:	4b0e      	ldr	r3, [pc, #56]	; (3b0 <_ZN4Nvic17activateInterruptE9interruptm.part.0.constprop.4+0x3c>)
void Nvic::activateInterrupt(interrupt myInterrupt, uint32_t priority)
 378:	b510      	push	{r4, lr}
        Register::setRegisterBitFieldStatus(((volatile uint32_t*)(corePeripheralBase + PRIn_OFFSET[myInterrupt/4])), priority, ((myInterrupt % nvicRegisterOffset) * 8) + 5, 3, RW);
 37a:	f000 0203 	and.w	r2, r0, #3
void Nvic::activateInterrupt(interrupt myInterrupt, uint32_t priority)
 37e:	4604      	mov	r4, r0
        Register::setRegisterBitFieldStatus(((volatile uint32_t*)(corePeripheralBase + PRIn_OFFSET[myInterrupt/4])), priority, ((myInterrupt % nvicRegisterOffset) * 8) + 5, 3, RW);
 380:	f853 0021 	ldr.w	r0, [r3, r1, lsl #2]
 384:	00d2      	lsls	r2, r2, #3
 386:	2303      	movs	r3, #3
 388:	4619      	mov	r1, r3
 38a:	3205      	adds	r2, #5
 38c:	f100 20e0 	add.w	r0, r0, #3758153728	; 0xe000e000
 390:	f7ff ffde 	bl	350 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0>
        Register::setRegisterBitFieldStatus(((volatile uint32_t*)(corePeripheralBase + ENn_OFFSET[myInterrupt/32])), (uint32_t)set, (uint32_t)(myInterrupt % 32), 1, RW);
 394:	0962      	lsrs	r2, r4, #5
 396:	4b07      	ldr	r3, [pc, #28]	; (3b4 <_ZN4Nvic17activateInterruptE9interruptm.part.0.constprop.4+0x40>)
 398:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
 39c:	2301      	movs	r3, #1
 39e:	f004 021f 	and.w	r2, r4, #31
 3a2:	4619      	mov	r1, r3
 3a4:	f100 20e0 	add.w	r0, r0, #3758153728	; 0xe000e000
}
 3a8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 3ac:	f7ff bfd0 	b.w	350 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0>
 3b0:	000009cc 	.word	0x000009cc
 3b4:	000009b8 	.word	0x000009b8

000003b8 <_ZN19GeneralPurposeTimer14interruptClearEv>:
    }

}

void GeneralPurposeTimer::interruptClear(void)
{
 3b8:	b410      	push	{r4}
    Register::setRegisterBitFieldStatus(((volatile uint32_t*)(baseAddress + GPTMICR_OFFSET)), set, interruptBit, 1, RW1C);
 3ba:	6884      	ldr	r4, [r0, #8]
 3bc:	6842      	ldr	r2, [r0, #4]
 3be:	2301      	movs	r3, #1
 3c0:	f104 0024 	add.w	r0, r4, #36	; 0x24
 3c4:	4619      	mov	r1, r3
}
 3c6:	f85d 4b04 	ldr.w	r4, [sp], #4
 3ca:	f7ff bfc1 	b.w	350 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0>

000003ce <_ZN4Gpio9gpioWriteE10setORClear.part.0>:
void Gpio::gpioWrite(setORClear value)
 3ce:	b410      	push	{r4}
        Register::setRegisterBitFieldStatus(((volatile uint32_t*)(gpioBaseAddress + GPIODATA_OFFSET)), value, gpioPin, 1, RW);
 3d0:	6844      	ldr	r4, [r0, #4]
 3d2:	6882      	ldr	r2, [r0, #8]
 3d4:	2301      	movs	r3, #1
 3d6:	f504 707f 	add.w	r0, r4, #1020	; 0x3fc
}
 3da:	f85d 4b04 	ldr.w	r4, [sp], #4
 3de:	f7ff bfb7 	b.w	350 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0>

000003e2 <_ZN4Gpio14interruptClearEv>:
{
 3e2:	b410      	push	{r4}
    Register::setRegisterBitFieldStatus(((volatile uint32_t*)(gpioBaseAddress + GPIOICR_OFFSET)), set, gpioPin, 1, RW);
 3e4:	6844      	ldr	r4, [r0, #4]
 3e6:	6882      	ldr	r2, [r0, #8]
 3e8:	2301      	movs	r3, #1
 3ea:	f204 401c 	addw	r0, r4, #1052	; 0x41c
 3ee:	4619      	mov	r1, r3
}
 3f0:	f85d 4b04 	ldr.w	r4, [sp], #4
 3f4:	f7ff bfac 	b.w	350 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0>

000003f8 <_ZN4GpioC1E14GPIO_Port_Pins9direction>:
Gpio::Gpio(GPIO_Port_Pins gpio, direction dir)
 3f8:	b570      	push	{r4, r5, r6, lr}
 3fa:	4b2c      	ldr	r3, [pc, #176]	; (4ac <Stack_Size+0xac>)
 3fc:	60c3      	str	r3, [r0, #12]
 3fe:	4604      	mov	r4, r0
    (*this).gpioBaseAddress = GPIO_Port_AHB_BASE + (((*this).gpio)/8) * 0x1000;
 400:	4b2b      	ldr	r3, [pc, #172]	; (4b0 <Stack_Size+0xb0>)
    (*this).gpio = gpio;
 402:	7021      	strb	r1, [r4, #0]
    (*this).gpioBaseAddress = GPIO_Port_AHB_BASE + (((*this).gpio)/8) * 0x1000;
 404:	6043      	str	r3, [r0, #4]
    (*this).gpioPin = (((*this).gpio % 8));
 406:	f001 0307 	and.w	r3, r1, #7
 40a:	6083      	str	r3, [r0, #8]
    else if((permission == RW) || (permission == WO) || (permission == RW1C))
 40c:	2301      	movs	r3, #1
 40e:	4829      	ldr	r0, [pc, #164]	; (4b4 <Stack_Size+0xb4>)
Gpio::Gpio(GPIO_Port_Pins gpio, direction dir)
 410:	460e      	mov	r6, r1
 412:	4615      	mov	r5, r2
 414:	4619      	mov	r1, r3
 416:	2205      	movs	r2, #5
 418:	f7ff ff9a 	bl	350 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0>
    while(Register::getRegisterBitFieldStatus(((volatile uint32_t*)(systemControlBase + PRGPIO_OFFSET)), (uint32_t)((*this).gpio)/8, 1, RO) == 0)
 41c:	7823      	ldrb	r3, [r4, #0]
        return(((*address) & select) >> bit);
 41e:	4826      	ldr	r0, [pc, #152]	; (4b8 <Stack_Size+0xb8>)
 420:	08db      	lsrs	r3, r3, #3
        uint32_t select = ((((0xFFFFFFFF >> (32 - bitWidth)))) << bit);
 422:	2101      	movs	r1, #1
 424:	4099      	lsls	r1, r3
        return(((*address) & select) >> bit);
 426:	6802      	ldr	r2, [r0, #0]
 428:	400a      	ands	r2, r1
 42a:	40da      	lsrs	r2, r3
 42c:	d0fb      	beq.n	426 <Stack_Size+0x26>
    if(gpio == PF0)
 42e:	2e28      	cmp	r6, #40	; 0x28
 430:	d110      	bne.n	454 <Stack_Size+0x54>
        Register::setRegisterBitFieldStatus(((volatile uint32_t*)(gpioBaseAddress + GPIOLOCK_OFFSET)), gpioKey, 0, 32, RW);
 432:	6860      	ldr	r0, [r4, #4]
 434:	68e1      	ldr	r1, [r4, #12]
 436:	2320      	movs	r3, #32
 438:	2200      	movs	r2, #0
 43a:	f500 60a4 	add.w	r0, r0, #1312	; 0x520
 43e:	f7ff ff87 	bl	350 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0>
        *(((volatile uint32_t*)(gpioBaseAddress + GPIOCR_OFFSET))) |= (0x1 << gpioPin);
 442:	6862      	ldr	r2, [r4, #4]
 444:	68a0      	ldr	r0, [r4, #8]
 446:	f8d2 1524 	ldr.w	r1, [r2, #1316]	; 0x524
 44a:	2301      	movs	r3, #1
 44c:	4083      	lsls	r3, r0
 44e:	430b      	orrs	r3, r1
 450:	f8c2 3524 	str.w	r3, [r2, #1316]	; 0x524
    Register::setRegisterBitFieldStatus(((volatile uint32_t*)(gpioBaseAddress + GPIODIR_OFFSET)), dir, gpioPin, 1, RW);
 454:	6860      	ldr	r0, [r4, #4]
 456:	68a2      	ldr	r2, [r4, #8]
 458:	2301      	movs	r3, #1
 45a:	4629      	mov	r1, r5
 45c:	f500 6080 	add.w	r0, r0, #1024	; 0x400
 460:	f7ff ff76 	bl	350 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0>
    if(dir == input)
 464:	b93d      	cbnz	r5, 476 <Stack_Size+0x76>
        Register::setRegisterBitFieldStatus(((volatile uint32_t*)(gpioBaseAddress + GPIOPUR_OFFSET)), set, gpioPin, 1, RW);
 466:	6860      	ldr	r0, [r4, #4]
 468:	68a2      	ldr	r2, [r4, #8]
 46a:	2301      	movs	r3, #1
 46c:	4619      	mov	r1, r3
 46e:	f500 60a2 	add.w	r0, r0, #1296	; 0x510
 472:	f7ff ff6d 	bl	350 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0>
    Register::setRegisterBitFieldStatus(((volatile uint32_t*)(gpioBaseAddress + GPIOAFSEl_OFFSET)), clear, gpioPin, 1, RW);
 476:	6860      	ldr	r0, [r4, #4]
 478:	68a2      	ldr	r2, [r4, #8]
 47a:	2301      	movs	r3, #1
 47c:	2100      	movs	r1, #0
 47e:	f500 6084 	add.w	r0, r0, #1056	; 0x420
 482:	f7ff ff65 	bl	350 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0>
    Register::setRegisterBitFieldStatus(((volatile uint32_t*)(gpioBaseAddress + GPIODEN_OFFSET)), set, gpioPin, 1, RW);
 486:	6860      	ldr	r0, [r4, #4]
 488:	68a2      	ldr	r2, [r4, #8]
 48a:	2301      	movs	r3, #1
 48c:	4619      	mov	r1, r3
 48e:	f200 501c 	addw	r0, r0, #1308	; 0x51c
 492:	f7ff ff5d 	bl	350 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0>
    Register::setRegisterBitFieldStatus(((volatile uint32_t*)(gpioBaseAddress + GPIOAMSEL_OFFSET)), clear, gpioPin, 1, RW);
 496:	6860      	ldr	r0, [r4, #4]
 498:	68a2      	ldr	r2, [r4, #8]
 49a:	2301      	movs	r3, #1
 49c:	2100      	movs	r1, #0
 49e:	f500 60a5 	add.w	r0, r0, #1320	; 0x528
 4a2:	f7ff ff55 	bl	350 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0>
}
 4a6:	4620      	mov	r0, r4
 4a8:	bd70      	pop	{r4, r5, r6, pc}
 4aa:	bf00      	nop
 4ac:	4c4f434b 	.word	0x4c4f434b
 4b0:	4005d000 	.word	0x4005d000
 4b4:	400fe608 	.word	0x400fe608
 4b8:	400fea08 	.word	0x400fea08

000004bc <_ZN4GpioC2E14GPIO_Port_Pins9directionm.constprop.0>:
Gpio::Gpio(GPIO_Port_Pins gpio, direction dir, uint32_t interruptPriority) : Gpio(gpio, dir)
 4bc:	b510      	push	{r4, lr}
 4be:	4604      	mov	r4, r0
 4c0:	2200      	movs	r2, #0
 4c2:	f7ff ff99 	bl	3f8 <_ZN4GpioC1E14GPIO_Port_Pins9direction>
    Register::setRegisterBitFieldStatus(((volatile uint32_t*)(gpioBaseAddress + GPIOIM_OFFSET)), clear, gpioPin, 1, RW);
 4c6:	6860      	ldr	r0, [r4, #4]
 4c8:	68a2      	ldr	r2, [r4, #8]
 4ca:	2301      	movs	r3, #1
 4cc:	2100      	movs	r1, #0
 4ce:	f500 6082 	add.w	r0, r0, #1040	; 0x410
 4d2:	f7ff ff3d 	bl	350 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0>
    Register::setRegisterBitFieldStatus(((volatile uint32_t*)(gpioBaseAddress + GPIOIS_OFFSET)), clear, gpioPin, 1, RW);
 4d6:	6860      	ldr	r0, [r4, #4]
 4d8:	68a2      	ldr	r2, [r4, #8]
 4da:	2301      	movs	r3, #1
 4dc:	2100      	movs	r1, #0
 4de:	f200 4004 	addw	r0, r0, #1028	; 0x404
 4e2:	f7ff ff35 	bl	350 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0>
    Register::setRegisterBitFieldStatus(((volatile uint32_t*)(gpioBaseAddress + GPIOIBE_OFFSET)), set, gpioPin, 1, RW);
 4e6:	6860      	ldr	r0, [r4, #4]
 4e8:	68a2      	ldr	r2, [r4, #8]
 4ea:	2301      	movs	r3, #1
 4ec:	4619      	mov	r1, r3
 4ee:	f500 6081 	add.w	r0, r0, #1032	; 0x408
 4f2:	f7ff ff2d 	bl	350 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0>
    Register::setRegisterBitFieldStatus(((volatile uint32_t*)(gpioBaseAddress + GPIOICR_OFFSET)), set, gpioPin, 1, RW);
 4f6:	6860      	ldr	r0, [r4, #4]
 4f8:	68a2      	ldr	r2, [r4, #8]
 4fa:	2301      	movs	r3, #1
 4fc:	4619      	mov	r1, r3
 4fe:	f200 401c 	addw	r0, r0, #1052	; 0x41c
 502:	f7ff ff25 	bl	350 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0>
    Register::setRegisterBitFieldStatus(((volatile uint32_t*)(gpioBaseAddress + GPIOIM_OFFSET)), set, gpioPin, 1, RW);
 506:	6860      	ldr	r0, [r4, #4]
 508:	68a2      	ldr	r2, [r4, #8]
 50a:	2301      	movs	r3, #1
 50c:	4619      	mov	r1, r3
 50e:	f500 6082 	add.w	r0, r0, #1040	; 0x410
 512:	f7ff ff1d 	bl	350 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0>
    Nvic::activateInterrupt((interrupt)((((((*this).gpio)/8) == 5) ? 30 : (((*this).gpio)/8))), interruptPriority);
 516:	7820      	ldrb	r0, [r4, #0]
 518:	f1a0 0328 	sub.w	r3, r0, #40	; 0x28
 51c:	2b07      	cmp	r3, #7
 51e:	bf8c      	ite	hi
 520:	08c0      	lsrhi	r0, r0, #3
 522:	201e      	movls	r0, #30
 524:	f7ff ff26 	bl	374 <_ZN4Nvic17activateInterruptE9interruptm.part.0.constprop.4>
}
 528:	4620      	mov	r0, r4
 52a:	bd10      	pop	{r4, pc}

0000052c <main>:
    blueLed = new Gpio(PF2, output);
    redLed = new Gpio(PF1, output);
}

int main(void)
{
 52c:	b508      	push	{r3, lr}

    Nvic::disableInterrupts();
 52e:	f7ff fedf 	bl	2f0 <_ZN4Nvic17disableInterruptsEv>


void* operator new(size_t size) noexcept 
{ 
    return malloc(size); 
 532:	2010      	movs	r0, #16
 534:	f000 f98a 	bl	84c <malloc>
    swtich1 = new Gpio(PF4, input, 3);
 538:	212c      	movs	r1, #44	; 0x2c
 53a:	4604      	mov	r4, r0
 53c:	f7ff ffbe 	bl	4bc <_ZN4GpioC2E14GPIO_Port_Pins9directionm.constprop.0>
 540:	4b38      	ldr	r3, [pc, #224]	; (624 <main+0xf8>)
 542:	2010      	movs	r0, #16
 544:	601c      	str	r4, [r3, #0]
 546:	f000 f981 	bl	84c <malloc>
    swtich2 = new Gpio(PF0, input, 3);
 54a:	2128      	movs	r1, #40	; 0x28
 54c:	4604      	mov	r4, r0
 54e:	f7ff ffb5 	bl	4bc <_ZN4GpioC2E14GPIO_Port_Pins9directionm.constprop.0>
 552:	4b35      	ldr	r3, [pc, #212]	; (628 <main+0xfc>)
 554:	200c      	movs	r0, #12
 556:	601c      	str	r4, [r3, #0]
 558:	f000 f978 	bl	84c <malloc>
    (*this).use = use;
 55c:	f44f 7381 	mov.w	r3, #258	; 0x102
 560:	8003      	strh	r3, [r0, #0]
    baseAddress = timerBaseAddresses[block];
 562:	4b32      	ldr	r3, [pc, #200]	; (62c <main+0x100>)
 564:	6083      	str	r3, [r0, #8]
GeneralPurposeTimer::GeneralPurposeTimer(timerMode mode, timerBlock block, uint32_t period, countDirection dir, timerUse use)
 566:	2200      	movs	r2, #0
 568:	2301      	movs	r3, #1
 56a:	6042      	str	r2, [r0, #4]
 56c:	4604      	mov	r4, r0
    else if((permission == RW) || (permission == WO) || (permission == RW1C))
 56e:	4619      	mov	r1, r3
 570:	482f      	ldr	r0, [pc, #188]	; (630 <main+0x104>)
 572:	f7ff feed 	bl	350 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0>
        return(((*address) & select) >> bit);
 576:	4a2f      	ldr	r2, [pc, #188]	; (634 <main+0x108>)
 578:	6813      	ldr	r3, [r2, #0]
    while(Register::getRegisterBitFieldStatus(((volatile uint32_t*)(systemControlBase + PRnTIMER_OFFSET[block/6])), (block%6), 1, RO) == 0)
 57a:	07db      	lsls	r3, r3, #31
 57c:	d5fc      	bpl.n	578 <main+0x4c>
    Register::setRegisterBitFieldStatus(((volatile uint32_t*)(baseAddress + GPTMCTL_OFFSET)), clear, (use%2)*8, 1, RW); //disable the timer
 57e:	68a0      	ldr	r0, [r4, #8]
 580:	2200      	movs	r2, #0
        interruptBit = ((use == timerB) ? 8 : 0);
 582:	2500      	movs	r5, #0
 584:	4611      	mov	r1, r2
 586:	2301      	movs	r3, #1
 588:	300c      	adds	r0, #12
 58a:	f7ff fee1 	bl	350 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0>
 58e:	462a      	mov	r2, r5
 590:	2303      	movs	r3, #3
 592:	4629      	mov	r1, r5
 594:	68a0      	ldr	r0, [r4, #8]
 596:	6065      	str	r5, [r4, #4]
    else if((permission == RW) || (permission == WO) || (permission == RW1C))
 598:	f7ff feda 	bl	350 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0>
        Register::setRegisterBitFieldStatus(((volatile uint32_t*)(baseAddress + GPTMTnMR_OFFSET[(use%2)])), mode + 1, 0, 2, RW);
 59c:	68a0      	ldr	r0, [r4, #8]
 59e:	2302      	movs	r3, #2
 5a0:	4619      	mov	r1, r3
 5a2:	3004      	adds	r0, #4
 5a4:	f7ff fed4 	bl	350 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0>
        Register::setRegisterBitFieldStatus(((volatile uint32_t*)(baseAddress + GPTMTnMR_OFFSET[(use%2)])), dir, 4, 1, RW);
 5a8:	68a0      	ldr	r0, [r4, #8]
 5aa:	2301      	movs	r3, #1
 5ac:	2204      	movs	r2, #4
 5ae:	4619      	mov	r1, r3
 5b0:	4410      	add	r0, r2
 5b2:	f7ff fecd 	bl	350 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0>
                Register::setRegisterBitFieldStatus(((volatile uint32_t*)(baseAddress + GPTMTAILR_OFFSET)), period, 0, 32, RW); //This is where the problems begin with reg B
 5b6:	68a3      	ldr	r3, [r4, #8]
            (*address) &= clear;
 5b8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 5ba:	629d      	str	r5, [r3, #40]	; 0x28
            (*address) |= value;
 5bc:	6a99      	ldr	r1, [r3, #40]	; 0x28
 5be:	4a1e      	ldr	r2, [pc, #120]	; (638 <main+0x10c>)
 5c0:	430a      	orrs	r2, r1
 5c2:	629a      	str	r2, [r3, #40]	; 0x28
                Register::setRegisterBitFieldStatus(((volatile uint32_t*)(baseAddress + GPTMTAPR_OFFSET)), clear, 0, 8, RW);
 5c4:	68a3      	ldr	r3, [r4, #8]
            (*address) &= clear;
 5c6:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 5c8:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
 5cc:	639a      	str	r2, [r3, #56]	; 0x38
            (*address) |= value;
 5ce:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 5d0:	639a      	str	r2, [r3, #56]	; 0x38
    interruptClear();
 5d2:	4620      	mov	r0, r4
 5d4:	f7ff fef0 	bl	3b8 <_ZN19GeneralPurposeTimer14interruptClearEv>
    Register::setRegisterBitFieldStatus(((volatile uint32_t*)(baseAddress + GPTMIMR_OFFSET)), set, interruptBit, 1, RW);
 5d8:	68a0      	ldr	r0, [r4, #8]
 5da:	6862      	ldr	r2, [r4, #4]
 5dc:	2301      	movs	r3, #1
 5de:	4619      	mov	r1, r3
 5e0:	3018      	adds	r0, #24
 5e2:	f7ff feb5 	bl	350 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0>
void Nvic::activateInterrupt(interrupt myInterrupt, uint32_t priority)
 5e6:	2013      	movs	r0, #19
 5e8:	f7ff fec4 	bl	374 <_ZN4Nvic17activateInterruptE9interruptm.part.0.constprop.4>
    testTimer = new GeneralPurposeTimer(periodic, shortTimer0, 80000000, down, concatenated, 3);
 5ec:	4b13      	ldr	r3, [pc, #76]	; (63c <main+0x110>)

void GeneralPurposeTimer::enableTimer(void)
{
    Register::setRegisterBitFieldStatus(((volatile uint32_t*)(baseAddress + GPTMCTL_OFFSET)), set, (use%2)*8, 1, RW);
 5ee:	7822      	ldrb	r2, [r4, #0]
 5f0:	68a0      	ldr	r0, [r4, #8]
 5f2:	601c      	str	r4, [r3, #0]
 5f4:	f002 0201 	and.w	r2, r2, #1
 5f8:	2301      	movs	r3, #1
 5fa:	4619      	mov	r1, r3
 5fc:	00d2      	lsls	r2, r2, #3
 5fe:	300c      	adds	r0, #12
 600:	f7ff fea6 	bl	350 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0>
    (*testTimer).enableTimer();
    Nvic::enableInterrupts();
 604:	f7ff fe83 	bl	30e <_ZN4Nvic16enableInterruptsEv>
    if((value == 0x0) || (value == 0x1))
 608:	4b0d      	ldr	r3, [pc, #52]	; (640 <main+0x114>)
 60a:	2101      	movs	r1, #1
 60c:	6818      	ldr	r0, [r3, #0]
 60e:	f7ff fede 	bl	3ce <_ZN4Gpio9gpioWriteE10setORClear.part.0>
 612:	4b0c      	ldr	r3, [pc, #48]	; (644 <main+0x118>)
 614:	2101      	movs	r1, #1
 616:	6818      	ldr	r0, [r3, #0]
 618:	f7ff fed9 	bl	3ce <_ZN4Gpio9gpioWriteE10setORClear.part.0>
    
    

    while(1)
    {
        Nvic::wfi();
 61c:	f7ff fe86 	bl	32c <_ZN4Nvic3wfiEv>
 620:	e7fc      	b.n	61c <main+0xf0>
 622:	bf00      	nop
 624:	20000098 	.word	0x20000098
 628:	2000009c 	.word	0x2000009c
 62c:	40030000 	.word	0x40030000
 630:	400fe604 	.word	0x400fe604
 634:	400fea04 	.word	0x400fea04
 638:	04c4b3ff 	.word	0x04c4b3ff
 63c:	200000a0 	.word	0x200000a0
 640:	2000008c 	.word	0x2000008c
 644:	20000094 	.word	0x20000094

00000648 <SystemInit>:
            (*address) &= clear;
 648:	4b49      	ldr	r3, [pc, #292]	; (770 <SystemInit+0x128>)
 64a:	681a      	ldr	r2, [r3, #0]
 64c:	f022 0201 	bic.w	r2, r2, #1
{
 650:	b510      	push	{r4, lr}
 652:	601a      	str	r2, [r3, #0]
            (*address) |= value;
 654:	681a      	ldr	r2, [r3, #0]
            (*address) &= clear;
 656:	4c47      	ldr	r4, [pc, #284]	; (774 <SystemInit+0x12c>)
            (*address) |= value;
 658:	f042 0201 	orr.w	r2, r2, #1
 65c:	601a      	str	r2, [r3, #0]
            (*address) &= clear;
 65e:	681a      	ldr	r2, [r3, #0]
 660:	f022 0202 	bic.w	r2, r2, #2
 664:	601a      	str	r2, [r3, #0]
            (*address) |= value;
 666:	681a      	ldr	r2, [r3, #0]
 668:	f042 0202 	orr.w	r2, r2, #2
 66c:	601a      	str	r2, [r3, #0]
            (*address) &= clear;
 66e:	681a      	ldr	r2, [r3, #0]
 670:	f022 0204 	bic.w	r2, r2, #4
 674:	601a      	str	r2, [r3, #0]
            (*address) |= value;
 676:	681a      	ldr	r2, [r3, #0]
 678:	f042 0204 	orr.w	r2, r2, #4
 67c:	601a      	str	r2, [r3, #0]
            (*address) &= clear;
 67e:	681a      	ldr	r2, [r3, #0]
 680:	f022 0208 	bic.w	r2, r2, #8
 684:	601a      	str	r2, [r3, #0]
            (*address) |= value;
 686:	681a      	ldr	r2, [r3, #0]
 688:	f042 0208 	orr.w	r2, r2, #8
 68c:	601a      	str	r2, [r3, #0]
            (*address) &= clear;
 68e:	681a      	ldr	r2, [r3, #0]
 690:	f022 0210 	bic.w	r2, r2, #16
 694:	601a      	str	r2, [r3, #0]
            (*address) |= value;
 696:	681a      	ldr	r2, [r3, #0]
 698:	f042 0210 	orr.w	r2, r2, #16
 69c:	601a      	str	r2, [r3, #0]
            (*address) &= clear;
 69e:	681a      	ldr	r2, [r3, #0]
 6a0:	f022 0220 	bic.w	r2, r2, #32
 6a4:	601a      	str	r2, [r3, #0]
            (*address) |= value;
 6a6:	681a      	ldr	r2, [r3, #0]
 6a8:	f042 0220 	orr.w	r2, r2, #32
 6ac:	601a      	str	r2, [r3, #0]
            (*address) &= clear;
 6ae:	6823      	ldr	r3, [r4, #0]
 6b0:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 6b4:	6023      	str	r3, [r4, #0]
            (*address) |= value;
 6b6:	6823      	ldr	r3, [r4, #0]
 6b8:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 6bc:	6023      	str	r3, [r4, #0]
            (*address) &= clear;
 6be:	6823      	ldr	r3, [r4, #0]
 6c0:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 6c4:	6023      	str	r3, [r4, #0]
            (*address) |= value;
 6c6:	6823      	ldr	r3, [r4, #0]
 6c8:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 6cc:	6023      	str	r3, [r4, #0]
            (*address) &= clear;
 6ce:	4b2a      	ldr	r3, [pc, #168]	; (778 <SystemInit+0x130>)
 6d0:	681a      	ldr	r2, [r3, #0]
 6d2:	f422 62f8 	bic.w	r2, r2, #1984	; 0x7c0
 6d6:	601a      	str	r2, [r3, #0]
            (*address) |= value;
 6d8:	681a      	ldr	r2, [r3, #0]
 6da:	f442 62a8 	orr.w	r2, r2, #1344	; 0x540
 6de:	601a      	str	r2, [r3, #0]
            (*address) &= clear;
 6e0:	6823      	ldr	r3, [r4, #0]
 6e2:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 6e6:	6023      	str	r3, [r4, #0]
            (*address) |= value;
 6e8:	6823      	ldr	r3, [r4, #0]
 6ea:	6023      	str	r3, [r4, #0]
            (*address) &= clear;
 6ec:	6823      	ldr	r3, [r4, #0]
 6ee:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 6f2:	6023      	str	r3, [r4, #0]
            (*address) |= value;
 6f4:	6823      	ldr	r3, [r4, #0]
 6f6:	6023      	str	r3, [r4, #0]
            (*address) &= clear;
 6f8:	6823      	ldr	r3, [r4, #0]
 6fa:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 6fe:	6023      	str	r3, [r4, #0]
            (*address) |= value;
 700:	6823      	ldr	r3, [r4, #0]
 702:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 706:	6023      	str	r3, [r4, #0]
    else if((permission == RW) || (permission == WO) || (permission == RW1C))
 708:	2216      	movs	r2, #22
 70a:	2301      	movs	r3, #1
 70c:	2100      	movs	r1, #0
 70e:	4620      	mov	r0, r4
 710:	f7ff fe1e 	bl	350 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0>
 714:	2217      	movs	r2, #23
 716:	2306      	movs	r3, #6
 718:	2102      	movs	r1, #2
 71a:	f7ff fe19 	bl	350 <_ZN8Register25setRegisterBitFieldStatusEPVmmmm18bitFieldPermission.part.0>
        return(((*address) & select) >> bit);
 71e:	4a17      	ldr	r2, [pc, #92]	; (77c <SystemInit+0x134>)
 720:	6813      	ldr	r3, [r2, #0]
	Register::setRegisterBitFieldStatus(((volatile uint32_t*)(systemControlBase + RCC2_OFFSET)), set, 30, 1, RW);
	
	Register::setRegisterBitFieldStatus(((volatile uint32_t*)(systemControlBase + RCC2_OFFSET)), ((frequency - 1) & 0x01), 22, 1, RW);
	Register::setRegisterBitFieldStatus(((volatile uint32_t*)(systemControlBase + RCC2_OFFSET)), ((frequency - 1) >> 1), 23, 6, RW);

	while((Register::getRegisterBitFieldStatus(((volatile uint32_t*)(systemControlBase + RIS_OFFSET)), 6, 1, RO)) == 0)  // 5. Wait for the PLL to lock by polling PLLRIS.
 722:	065b      	lsls	r3, r3, #25
 724:	d5fc      	bpl.n	720 <SystemInit+0xd8>
            (*address) &= clear;
 726:	6823      	ldr	r3, [r4, #0]
 728:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 72c:	6023      	str	r3, [r4, #0]
            (*address) |= value;
 72e:	6823      	ldr	r3, [r4, #0]
 730:	6023      	str	r3, [r4, #0]
    return malloc(size); 
 732:	2010      	movs	r0, #16
 734:	f000 f88a 	bl	84c <malloc>
    greenLed = new Gpio(PF3, output);
 738:	2201      	movs	r2, #1
 73a:	212b      	movs	r1, #43	; 0x2b
 73c:	4604      	mov	r4, r0
 73e:	f7ff fe5b 	bl	3f8 <_ZN4GpioC1E14GPIO_Port_Pins9direction>
 742:	4b0f      	ldr	r3, [pc, #60]	; (780 <SystemInit+0x138>)
 744:	2010      	movs	r0, #16
 746:	601c      	str	r4, [r3, #0]
 748:	f000 f880 	bl	84c <malloc>
    blueLed = new Gpio(PF2, output);
 74c:	2201      	movs	r2, #1
 74e:	212a      	movs	r1, #42	; 0x2a
 750:	4604      	mov	r4, r0
 752:	f7ff fe51 	bl	3f8 <_ZN4GpioC1E14GPIO_Port_Pins9direction>
 756:	4b0b      	ldr	r3, [pc, #44]	; (784 <SystemInit+0x13c>)
 758:	2010      	movs	r0, #16
 75a:	601c      	str	r4, [r3, #0]
 75c:	f000 f876 	bl	84c <malloc>
    redLed = new Gpio(PF1, output);
 760:	2201      	movs	r2, #1
 762:	2129      	movs	r1, #41	; 0x29
 764:	4604      	mov	r4, r0
 766:	f7ff fe47 	bl	3f8 <_ZN4GpioC1E14GPIO_Port_Pins9direction>
 76a:	4b07      	ldr	r3, [pc, #28]	; (788 <SystemInit+0x140>)
 76c:	601c      	str	r4, [r3, #0]
}
 76e:	bd10      	pop	{r4, pc}
 770:	400fe06c 	.word	0x400fe06c
 774:	400fe070 	.word	0x400fe070
 778:	400fe060 	.word	0x400fe060
 77c:	400fe050 	.word	0x400fe050
 780:	20000090 	.word	0x20000090
 784:	2000008c 	.word	0x2000008c
 788:	20000094 	.word	0x20000094

0000078c <_16_32_Bit_Timer_0A_Handler>:
    if((*greenLed).gpioRead() == set)
 78c:	4b0c      	ldr	r3, [pc, #48]	; (7c0 <_16_32_Bit_Timer_0A_Handler+0x34>)
{
 78e:	b510      	push	{r4, lr}
    if((*greenLed).gpioRead() == set)
 790:	681c      	ldr	r4, [r3, #0]
 792:	4620      	mov	r0, r4
 794:	f7ff fdd2 	bl	33c <_ZN4Gpio8gpioReadEv>
 798:	2801      	cmp	r0, #1
 79a:	d109      	bne.n	7b0 <_16_32_Bit_Timer_0A_Handler+0x24>
 79c:	2100      	movs	r1, #0
 79e:	4620      	mov	r0, r4
 7a0:	f7ff fe15 	bl	3ce <_ZN4Gpio9gpioWriteE10setORClear.part.0>
        (*testTimer).interruptClear();
 7a4:	4b07      	ldr	r3, [pc, #28]	; (7c4 <_16_32_Bit_Timer_0A_Handler+0x38>)
}
 7a6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        (*testTimer).interruptClear();
 7aa:	6818      	ldr	r0, [r3, #0]
 7ac:	f7ff be04 	b.w	3b8 <_ZN19GeneralPurposeTimer14interruptClearEv>
    else if((*greenLed).gpioRead() == clear)
 7b0:	4620      	mov	r0, r4
 7b2:	f7ff fdc3 	bl	33c <_ZN4Gpio8gpioReadEv>
 7b6:	b908      	cbnz	r0, 7bc <_16_32_Bit_Timer_0A_Handler+0x30>
 7b8:	2101      	movs	r1, #1
 7ba:	e7f0      	b.n	79e <_16_32_Bit_Timer_0A_Handler+0x12>
}
 7bc:	bd10      	pop	{r4, pc}
 7be:	bf00      	nop
 7c0:	20000090 	.word	0x20000090
 7c4:	200000a0 	.word	0x200000a0

000007c8 <GPIO_Port_F_Handler>:
    if((*swtich1).gpioRead() == 1)
 7c8:	4b1c      	ldr	r3, [pc, #112]	; (83c <GPIO_Port_F_Handler+0x74>)
{
 7ca:	b510      	push	{r4, lr}
    if((*swtich1).gpioRead() == 1)
 7cc:	681c      	ldr	r4, [r3, #0]
 7ce:	4620      	mov	r0, r4
 7d0:	f7ff fdb4 	bl	33c <_ZN4Gpio8gpioReadEv>
 7d4:	2801      	cmp	r0, #1
 7d6:	d107      	bne.n	7e8 <GPIO_Port_F_Handler+0x20>
 7d8:	4b19      	ldr	r3, [pc, #100]	; (840 <GPIO_Port_F_Handler+0x78>)
 7da:	2100      	movs	r1, #0
 7dc:	6818      	ldr	r0, [r3, #0]
 7de:	f7ff fdf6 	bl	3ce <_ZN4Gpio9gpioWriteE10setORClear.part.0>
        (*swtich1).interruptClear();
 7e2:	4620      	mov	r0, r4
 7e4:	f7ff fdfd 	bl	3e2 <_ZN4Gpio14interruptClearEv>
    if((*swtich1).gpioRead() == 0)
 7e8:	4620      	mov	r0, r4
 7ea:	f7ff fda7 	bl	33c <_ZN4Gpio8gpioReadEv>
 7ee:	b938      	cbnz	r0, 800 <GPIO_Port_F_Handler+0x38>
 7f0:	4b13      	ldr	r3, [pc, #76]	; (840 <GPIO_Port_F_Handler+0x78>)
 7f2:	2101      	movs	r1, #1
 7f4:	6818      	ldr	r0, [r3, #0]
 7f6:	f7ff fdea 	bl	3ce <_ZN4Gpio9gpioWriteE10setORClear.part.0>
        (*swtich1).interruptClear();
 7fa:	4620      	mov	r0, r4
 7fc:	f7ff fdf1 	bl	3e2 <_ZN4Gpio14interruptClearEv>
    if((*swtich2).gpioRead() == 1)
 800:	4b10      	ldr	r3, [pc, #64]	; (844 <GPIO_Port_F_Handler+0x7c>)
 802:	681c      	ldr	r4, [r3, #0]
 804:	4620      	mov	r0, r4
 806:	f7ff fd99 	bl	33c <_ZN4Gpio8gpioReadEv>
 80a:	2801      	cmp	r0, #1
 80c:	d107      	bne.n	81e <GPIO_Port_F_Handler+0x56>
 80e:	4b0e      	ldr	r3, [pc, #56]	; (848 <GPIO_Port_F_Handler+0x80>)
 810:	2100      	movs	r1, #0
 812:	6818      	ldr	r0, [r3, #0]
 814:	f7ff fddb 	bl	3ce <_ZN4Gpio9gpioWriteE10setORClear.part.0>
        (*swtich2).interruptClear();
 818:	4620      	mov	r0, r4
 81a:	f7ff fde2 	bl	3e2 <_ZN4Gpio14interruptClearEv>
    if((*swtich2).gpioRead() == 0)
 81e:	4620      	mov	r0, r4
 820:	f7ff fd8c 	bl	33c <_ZN4Gpio8gpioReadEv>
 824:	b948      	cbnz	r0, 83a <GPIO_Port_F_Handler+0x72>
 826:	4b08      	ldr	r3, [pc, #32]	; (848 <GPIO_Port_F_Handler+0x80>)
 828:	2101      	movs	r1, #1
 82a:	6818      	ldr	r0, [r3, #0]
 82c:	f7ff fdcf 	bl	3ce <_ZN4Gpio9gpioWriteE10setORClear.part.0>
        (*swtich2).interruptClear();
 830:	4620      	mov	r0, r4
}
 832:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        (*swtich2).interruptClear();
 836:	f7ff bdd4 	b.w	3e2 <_ZN4Gpio14interruptClearEv>
}
 83a:	bd10      	pop	{r4, pc}
 83c:	20000098 	.word	0x20000098
 840:	20000094 	.word	0x20000094
 844:	2000009c 	.word	0x2000009c
 848:	2000008c 	.word	0x2000008c

0000084c <malloc>:
 84c:	4b02      	ldr	r3, [pc, #8]	; (858 <malloc+0xc>)
 84e:	4601      	mov	r1, r0
 850:	6818      	ldr	r0, [r3, #0]
 852:	f000 b82f 	b.w	8b4 <_malloc_r>
 856:	bf00      	nop
 858:	20000000 	.word	0x20000000

0000085c <_sbrk>:
 85c:	4b0d      	ldr	r3, [pc, #52]	; (894 <_sbrk+0x38>)
 85e:	6819      	ldr	r1, [r3, #0]
 860:	b510      	push	{r4, lr}
 862:	4602      	mov	r2, r0
 864:	b909      	cbnz	r1, 86a <_sbrk+0xe>
 866:	490c      	ldr	r1, [pc, #48]	; (898 <_sbrk+0x3c>)
 868:	6019      	str	r1, [r3, #0]
 86a:	6818      	ldr	r0, [r3, #0]
 86c:	4669      	mov	r1, sp
 86e:	4402      	add	r2, r0
 870:	428a      	cmp	r2, r1
 872:	d806      	bhi.n	882 <_sbrk+0x26>
 874:	4909      	ldr	r1, [pc, #36]	; (89c <_sbrk+0x40>)
 876:	4c0a      	ldr	r4, [pc, #40]	; (8a0 <_sbrk+0x44>)
 878:	6809      	ldr	r1, [r1, #0]
 87a:	42a1      	cmp	r1, r4
 87c:	d008      	beq.n	890 <_sbrk+0x34>
 87e:	428a      	cmp	r2, r1
 880:	d906      	bls.n	890 <_sbrk+0x34>
 882:	f000 f80f 	bl	8a4 <__errno>
 886:	230c      	movs	r3, #12
 888:	6003      	str	r3, [r0, #0]
 88a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 88e:	bd10      	pop	{r4, pc}
 890:	601a      	str	r2, [r3, #0]
 892:	e7fc      	b.n	88e <_sbrk+0x32>
 894:	200000a4 	.word	0x200000a4
 898:	200000c0 	.word	0x200000c0
 89c:	20000064 	.word	0x20000064
 8a0:	cafedead 	.word	0xcafedead

000008a4 <__errno>:
 8a4:	4b01      	ldr	r3, [pc, #4]	; (8ac <__errno+0x8>)
 8a6:	6818      	ldr	r0, [r3, #0]
 8a8:	4770      	bx	lr
 8aa:	bf00      	nop
 8ac:	20000000 	.word	0x20000000

000008b0 <__retarget_lock_acquire_recursive>:
 8b0:	4770      	bx	lr

000008b2 <__retarget_lock_release_recursive>:
 8b2:	4770      	bx	lr

000008b4 <_malloc_r>:
 8b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8b6:	1ccd      	adds	r5, r1, #3
 8b8:	f025 0503 	bic.w	r5, r5, #3
 8bc:	3508      	adds	r5, #8
 8be:	2d0c      	cmp	r5, #12
 8c0:	bf38      	it	cc
 8c2:	250c      	movcc	r5, #12
 8c4:	2d00      	cmp	r5, #0
 8c6:	4606      	mov	r6, r0
 8c8:	db01      	blt.n	8ce <_malloc_r+0x1a>
 8ca:	42a9      	cmp	r1, r5
 8cc:	d903      	bls.n	8d6 <_malloc_r+0x22>
 8ce:	230c      	movs	r3, #12
 8d0:	6033      	str	r3, [r6, #0]
 8d2:	2000      	movs	r0, #0
 8d4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8d6:	f000 f857 	bl	988 <__malloc_lock>
 8da:	4921      	ldr	r1, [pc, #132]	; (960 <_malloc_r+0xac>)
 8dc:	680a      	ldr	r2, [r1, #0]
 8de:	4614      	mov	r4, r2
 8e0:	b99c      	cbnz	r4, 90a <_malloc_r+0x56>
 8e2:	4f20      	ldr	r7, [pc, #128]	; (964 <_malloc_r+0xb0>)
 8e4:	683b      	ldr	r3, [r7, #0]
 8e6:	b923      	cbnz	r3, 8f2 <_malloc_r+0x3e>
 8e8:	4621      	mov	r1, r4
 8ea:	4630      	mov	r0, r6
 8ec:	f000 f83c 	bl	968 <_sbrk_r>
 8f0:	6038      	str	r0, [r7, #0]
 8f2:	4629      	mov	r1, r5
 8f4:	4630      	mov	r0, r6
 8f6:	f000 f837 	bl	968 <_sbrk_r>
 8fa:	1c43      	adds	r3, r0, #1
 8fc:	d123      	bne.n	946 <_malloc_r+0x92>
 8fe:	230c      	movs	r3, #12
 900:	6033      	str	r3, [r6, #0]
 902:	4630      	mov	r0, r6
 904:	f000 f846 	bl	994 <__malloc_unlock>
 908:	e7e3      	b.n	8d2 <_malloc_r+0x1e>
 90a:	6823      	ldr	r3, [r4, #0]
 90c:	1b5b      	subs	r3, r3, r5
 90e:	d417      	bmi.n	940 <_malloc_r+0x8c>
 910:	2b0b      	cmp	r3, #11
 912:	d903      	bls.n	91c <_malloc_r+0x68>
 914:	6023      	str	r3, [r4, #0]
 916:	441c      	add	r4, r3
 918:	6025      	str	r5, [r4, #0]
 91a:	e004      	b.n	926 <_malloc_r+0x72>
 91c:	6863      	ldr	r3, [r4, #4]
 91e:	42a2      	cmp	r2, r4
 920:	bf0c      	ite	eq
 922:	600b      	streq	r3, [r1, #0]
 924:	6053      	strne	r3, [r2, #4]
 926:	4630      	mov	r0, r6
 928:	f000 f834 	bl	994 <__malloc_unlock>
 92c:	f104 000b 	add.w	r0, r4, #11
 930:	1d23      	adds	r3, r4, #4
 932:	f020 0007 	bic.w	r0, r0, #7
 936:	1ac2      	subs	r2, r0, r3
 938:	d0cc      	beq.n	8d4 <_malloc_r+0x20>
 93a:	1a1b      	subs	r3, r3, r0
 93c:	50a3      	str	r3, [r4, r2]
 93e:	e7c9      	b.n	8d4 <_malloc_r+0x20>
 940:	4622      	mov	r2, r4
 942:	6864      	ldr	r4, [r4, #4]
 944:	e7cc      	b.n	8e0 <_malloc_r+0x2c>
 946:	1cc4      	adds	r4, r0, #3
 948:	f024 0403 	bic.w	r4, r4, #3
 94c:	42a0      	cmp	r0, r4
 94e:	d0e3      	beq.n	918 <_malloc_r+0x64>
 950:	1a21      	subs	r1, r4, r0
 952:	4630      	mov	r0, r6
 954:	f000 f808 	bl	968 <_sbrk_r>
 958:	3001      	adds	r0, #1
 95a:	d1dd      	bne.n	918 <_malloc_r+0x64>
 95c:	e7cf      	b.n	8fe <_malloc_r+0x4a>
 95e:	bf00      	nop
 960:	200000a8 	.word	0x200000a8
 964:	200000ac 	.word	0x200000ac

00000968 <_sbrk_r>:
 968:	b538      	push	{r3, r4, r5, lr}
 96a:	4c06      	ldr	r4, [pc, #24]	; (984 <_sbrk_r+0x1c>)
 96c:	2300      	movs	r3, #0
 96e:	4605      	mov	r5, r0
 970:	4608      	mov	r0, r1
 972:	6023      	str	r3, [r4, #0]
 974:	f7ff ff72 	bl	85c <_sbrk>
 978:	1c43      	adds	r3, r0, #1
 97a:	d102      	bne.n	982 <_sbrk_r+0x1a>
 97c:	6823      	ldr	r3, [r4, #0]
 97e:	b103      	cbz	r3, 982 <_sbrk_r+0x1a>
 980:	602b      	str	r3, [r5, #0]
 982:	bd38      	pop	{r3, r4, r5, pc}
 984:	200000bc 	.word	0x200000bc

00000988 <__malloc_lock>:
 988:	4801      	ldr	r0, [pc, #4]	; (990 <__malloc_lock+0x8>)
 98a:	f7ff bf91 	b.w	8b0 <__retarget_lock_acquire_recursive>
 98e:	bf00      	nop
 990:	200000b4 	.word	0x200000b4

00000994 <__malloc_unlock>:
 994:	4801      	ldr	r0, [pc, #4]	; (99c <__malloc_unlock+0x8>)
 996:	f7ff bf8c 	b.w	8b2 <__retarget_lock_release_recursive>
 99a:	bf00      	nop
 99c:	200000b4 	.word	0x200000b4

000009a0 <_init>:
 9a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 9a2:	bf00      	nop
 9a4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 9a6:	bc08      	pop	{r3}
 9a8:	469e      	mov	lr, r3
 9aa:	4770      	bx	lr

000009ac <_fini>:
 9ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 9ae:	bf00      	nop
 9b0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 9b2:	bc08      	pop	{r3}
 9b4:	469e      	mov	lr, r3
 9b6:	4770      	bx	lr

000009b8 <_ZN4Nvic10ENn_OFFSETE>:
 9b8:	0100 0000 0104 0000 0108 0000 010c 0000     ................
 9c8:	0110 0000                                   ....

000009cc <_ZN4Nvic11PRIn_OFFSETE>:
 9cc:	0400 0000 0404 0000 0408 0000 040c 0000     ................
 9dc:	040c 0000 0414 0000 0418 0000 041c 0000     ................
 9ec:	0420 0000 0424 0000 0428 0000 042c 0000      ...$...(...,...
 9fc:	0430 0000 0434 0000 0438 0000 043c 0000     0...4...8...<...
 a0c:	0440 0000 0444 0000 0448 0000 044c 0000     @...D...H...L...
 a1c:	0450 0000 0454 0000 0458 0000 045c 0000     P...T...X...\...
 a2c:	0460 0000 0464 0000 0468 0000 046c 0000     `...d...h...l...
 a3c:	0470 0000 0474 0000 0478 0000 047c 0000     p...t...x...|...
 a4c:	0480 0000 0484 0000 0488 0000               ............

00000a58 <__sf_fake_stderr>:
	...

00000a78 <__sf_fake_stdin>:
	...

00000a98 <__sf_fake_stdout>:
	...

00000ab8 <__EH_FRAME_BEGIN__>:
 ab8:	0000 0000                                   ....
